<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compteur de FlÃ©chettes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark base for gradient */
            background-image: radial-gradient(at 50% 0%, #2d3748, #1a202c 70%); /* Subtle radial gradient from top */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
            cursor: pointer;
        }

        /* Enhanced button styles with more pronounced effects */
        .btn-gradient {
            background-size: 200% auto;
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease-in-out;
            border: none;
            cursor: pointer;
            position: relative; /* For ripple effect */
            overflow: hidden; /* For ripple effect */
        }
        .btn-gradient:hover {
            background-position: right center; /* Change the gradient position */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            transform: translateY(-3px);
        }
        .btn-gradient:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary { background-image: linear-gradient(to right, #6366f1 0%, #8b5cf6 50%, #6366f1 100%); }
        .btn-success { background-image: linear-gradient(to right, #10b981 0%, #34d399 50%, #10b981 100%); }
        .btn-danger { background-image: linear-gradient(to right, #ef4444 0%, #f87171 50%, #ef4444 100%); }
        .btn-info { background-image: linear-gradient(to right, #0ea5e9 0%, #38bdf8 50%, #0ea5e9 100%); }
        .btn-dark-gradient { background-image: linear-gradient(to right, #4b5563 0%, #6b7280 50%, #4b5563 100%); }

        /* Specific styles for selected multiplier button */
        .btn-multiplier-selected {
            border: 3px solid #facc15; /* Yellow 400 */
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.8), inset 0 0 10px rgba(250, 204, 21, 0.5);
            transform: scale(1.05);
        }

        /* Player card active state */
        .player-card-active {
            border: 3px solid #3b82f6; /* Blue 500 */
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.8), inset 0 0 15px rgba(59, 130, 246, 0.5);
            transform: scale(1.03);
        }

        /* Main container shadow */
        .main-container {
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7), 0 0 0 5px rgba(255, 255, 255, 0.05) inset;
            border-radius: 1rem;
            background-color: #2d3748; /* Darker background for content */
        }

        /* Input field focus glow */
        input:focus, select:focus {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); /* Blue 500 with transparency */
            border-color: #3b82f6;
            outline: none; /* Remove default outline */
        }
        /* Style for the statistics canvas */
        #dartboardCanvas {
            background-color: #f0f0f0; /* Light background for the board */
            border-radius: 0.5rem;
            margin: 0 auto; /* Center the canvas */
            display: block; /* Ensure it behaves like a block element for centering */
        }

        /* Ripple effect for buttons */
        .ripple {
            background-color: rgba(255, 255, 255, 0.7);
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 text-white p-4 sm:p-8 flex flex-col items-center justify-center">

    <div class="main-container p-6 sm:p-8 w-full max-w-4xl border border-gray-700">
        <h1 class="text-5xl font-extrabold text-center mb-8 text-yellow-400 drop-shadow-lg tracking-wide">
            ðŸŽ¯ Compteur de FlÃ©chettes ðŸŽ¯
        </h1>

        <div id="config-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600">
            <h2 class="text-2xl font-bold mb-4 text-center text-blue-300">Configuration du Jeu</h2>

            <div class="mb-4">
                <label for="newPlayer" class="block text-lg font-medium mb-2 text-gray-200">
                    Ajouter un joueur:
                </label>
                <div class="flex flex-col sm:flex-row gap-2">
                    <input
                        type="text"
                        id="newPlayer"
                        class="flex-grow p-3 rounded-md bg-gray-900 border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="Nom du joueur"
                        aria-label="Nom du nouveau joueur"
                    />
                    <button
                        id="addPlayerBtn"
                        class="btn-gradient btn-primary text-white font-bold py-3 px-6 rounded-md flex items-center justify-center gap-2"
                        aria-label="Ajouter un nouveau joueur"
                    >
                        <i class="fas fa-user-plus"></i> Ajouter
                    </button>
                </div>
            </div>

            <div id="players-list-container" class="mb-4 hidden">
                <h3 class="text-xl font-semibold mb-2 text-purple-300">Joueurs:</h3>
                <ul id="players-list" class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                    </ul>
            </div>

            <div class="mb-6">
                <label for="gameMode" class="block text-lg font-medium mb-2 text-gray-200">
                    Mode de jeu:
                </label>
                <select
                    id="gameMode"
                    class="w-full p-3 rounded-md bg-gray-900 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    aria-label="SÃ©lectionner le mode de jeu"
                >
                    <option value="301">301</option>
                    <option value="501">501</option>
                    <option value="atc">Around the Clock</option>
                </select>
            </div>

            <div id="x01-rules" class="mb-6">
                <h3 class="text-xl font-semibold mb-2 text-green-300">Options de RÃ¨gles (301/501):</h3>
                <div class="flex items-center mb-2">
                    <input
                        type="checkbox"
                        id="doubleIn"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                        aria-label="Activer la rÃ¨gle Double In"
                    />
                    <label for="doubleIn" class="ml-2 text-lg text-gray-200">Double In</label>
                </div>
                <div class="flex items-center">
                    <input
                        type="checkbox"
                        id="doubleOut"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                        aria-label="Activer la rÃ¨gle Double Out"
                    />
                    <label for="doubleOut" class="ml-2 text-lg text-gray-200">Double Out</label>
                </div>
            </div>

            <div id="atc-rules" class="mb-6 hidden">
                <h3 class="text-xl font-semibold mb-2 text-green-300">Types de coups valides (Around the Clock):</h3>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex items-center">
                        <input
                            type="checkbox"
                            id="atcAllowSimple"
                            class="form-checkbox h-5 w-5 text-blue-600 rounded"
                            aria-label="Autoriser les coups simples pour Around the Clock"
                        />
                        <label for="atcAllowSimple" class="ml-2 text-lg text-gray-200">Simple</label>
                    </div>
                    <div class="flex items-center">
                        <input
                            type="checkbox"
                            id="atcAllowDouble"
                            class="form-checkbox h-5 w-5 text-blue-600 rounded"
                            aria-label="Autoriser les coups doubles pour Around the Clock"
                        />
                        <label for="atcAllowDouble" class="ml-2 text-lg text-gray-200">Double</label>
                    </div>
                    <div class="flex items-center">
                        <input
                            type="checkbox"
                            id="atcAllowTriple"
                            class="form-checkbox h-5 w-5 text-blue-600 rounded"
                            aria-label="Autoriser les coups triples pour Around the Clock"
                        />
                        <label for="atcAllowTriple" class="ml-2 text-lg text-gray-200">Triple</label>
                    </div>
                </div>
            </div>

            <div class="flex items-center mt-4 mb-6">
                <input
                    type="checkbox"
                    id="enableVoice"
                    class="form-checkbox h-5 w-5 text-blue-600 rounded"
                    checked
                    aria-label="Activer la voix de l'IA"
                />
                <label for="enableVoice" class="ml-2 text-lg text-gray-200">Activer la voix de l'IA</label>
            </div>

            <button
                id="startGameBtn"
                class="btn-gradient btn-success w-full text-white font-bold py-3 px-6 rounded-md flex items-center justify-center gap-2"
                aria-label="DÃ©marrer le jeu"
            >
                <i class="fas fa-play-circle"></i> DÃ©marrer le Jeu
            </button>
        </div>

        <div id="game-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 id="game-mode-display" class="text-2xl font-bold mb-4 text-center text-yellow-300">
                Jeu en Cours: 501
            </h2>

            <div id="player-scores-display" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                </div>

            <div class="mb-4 text-center">
                <p class="text-xl font-semibold mb-2 text-orange-300">
                    C'est au tour de: <span id="current-player-name" class="text-yellow-400 font-extrabold text-2xl"></span>
                </p>

                <div class="bg-gray-900 p-3 rounded-md mb-4 border border-gray-600 shadow-md">
                    <p class="text-lg font-medium text-gray-300">
                        FlÃ©chettes du tour (<span id="darts-count" class="font-bold text-white">0</span>/3):
                        <span id="current-darts-display" class="font-bold text-white ml-2">Aucune</span>
                    </p>
                    <p class="text-lg font-medium text-gray-300 mt-1">
                        Multiplicateur sÃ©lectionnÃ©: <span id="selected-multiplier-display" class="font-bold text-yellow-300">Simple</span>
                    </p>
                </div>

                <div class="flex justify-center gap-2 mb-4">
                    <button
                        id="multiplier-simple"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-info"
                        aria-label="SÃ©lectionner multiplicateur simple"
                    >
                        Simple (S)
                    </button>
                    <button
                        id="multiplier-double"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-dark-gradient"
                        aria-label="SÃ©lectionner multiplicateur double"
                    >
                        Double (D)
                    </button>
                    <button
                        id="multiplier-triple"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-dark-gradient"
                        aria-label="SÃ©lectionner multiplicateur triple"
                    >
                        Triple (T)
                    </button>
                </div>

                <div id="number-keypad" class="grid grid-cols-5 sm:grid-cols-7 gap-2 mb-4">
                    </div>

                <div class="flex justify-center mt-4">
                    <button
                        id="undoLastDartBtn"
                        class="btn-gradient btn-danger font-bold py-3 px-8 rounded-md opacity-50 cursor-not-allowed flex items-center justify-center gap-2"
                        disabled
                        aria-label="Annuler la derniÃ¨re flÃ©chette lancÃ©e"
                    >
                        <i class="fas fa-undo"></i> Annuler la derniÃ¨re flÃ©chette
                    </button>
                </div>
            </div>
        </div>

        <div id="winner-section" class="text-center p-6 bg-green-700 rounded-lg shadow-xl border border-green-500 hidden">
            <h2 class="text-3xl font-bold text-white mb-4">ðŸŽ‰ FÃ©licitations ðŸŽ‰</h2>
            <p id="winner-name" class="text-4xl font-extrabold text-yellow-300 mb-6"></p>
            <button
                id="newGameWinnerBtn"
                class="btn-gradient btn-primary text-white font-bold py-3 px-8 rounded-md flex items-center justify-center gap-2"
                aria-label="DÃ©marrer un nouveau jeu"
            >
                <i class="fas fa-redo-alt"></i> Nouveau Jeu
            </button>
            <button
                id="showStatsBtn"
                class="btn-gradient btn-info text-white font-bold py-3 px-8 rounded-md mt-4 ml-4 flex items-center justify-center gap-2"
                aria-label="Afficher les statistiques de la partie"
            >
                <i class="fas fa-chart-bar"></i> Statistiques
            </button>
        </div>

        <div id="message-section" class="mt-6 p-4 bg-red-600 rounded-md text-white text-center font-medium shadow-md hidden" role="alert" aria-live="polite">
            <span id="message-text"></span>
        </div>

        <div id="history-section" class="mt-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 class="text-2xl font-bold mb-4 text-center text-cyan-300">Historique des Scores</h2>
            <div id="history-content" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                </div>
        </div>

        <div id="stats-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 class="text-3xl font-bold mb-6 text-center text-yellow-300">Statistiques de la Partie</h2>
            <div id="player-stats-summary" class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                </div>
            <div class="flex justify-center">
                <button
                    id="backToMainFromStatsBtn"
                    class="btn-gradient btn-primary text-white font-bold py-3 px-8 rounded-md flex items-center justify-center gap-2"
                    aria-label="Retourner au menu principal depuis les statistiques"
                >
                    <i class="fas fa-arrow-left"></i> Retour au menu principal
                </button>
            </div>
        </div>

        <div id="reset-game-btn-container" class="mt-6 text-center hidden">
            <button
                id="resetGameBtn"
                class="btn-gradient btn-danger font-bold py-3 px-8 rounded-md flex items-center justify-center gap-2"
                aria-label="RÃ©initialiser complÃ¨tement le jeu"
            >
                <i class="fas fa-power-off"></i> RÃ©initialiser le Jeu
            </button>
        </div>
    </div>

    <script>
        // Global State
        let players = [];
        let newPlayerName = '';
        let gameMode = 501; // Can be 301, 501, atc
        let playerScores = {}; // For 301/501, it's the remaining score. For ATC, it's the current target number.
        let currentPlayerIndex = 0;
        let gameStarted = false;
        let winner = null;
        let message = '';
        let history = {}; // Stores { darts: [], scoreEntered, newTotal, message } for each turn
        let allDartsThrown = {}; // Stores ALL individual darts thrown by each player for stats
        let gameEnded = false; // Global variable for game ended state

        let doubleInActive = false;
        let doubleOutActive = false;
        let playerHasDoubledIn = {}; // Used only for 301/501 modes

        // ATC specific state
        let atcMode = null; // Will be 'atc' if Around the Clock is selected
        let atcAllowedHitTypes = { simple: false, double: false, triple: false }; // New: for ATC rules, default all unchecked

        let currentDartsThrown = [];
        let selectedMultiplier = 1; // 1: Simple, 2: Double, 3: Triple

        // AI Voice State
        let isVoiceActive = true; // Default to active
        let speechSynth = window.speechSynthesis;
        let voices = [];
        let speakingQueue = []; // Queue for sequential speaking
        let isSpeaking = false; // Flag to indicate if speech is in progress
        let areVoicesLoaded = false; // New flag to track if voices are loaded

        // Pre-defined AI comments/citations for general turn announcements (only used for game start)
        const aiComments = [
            "Allez, les tafiolles, on sort les flÃ©chettes de son cul, c'est parti pour ce tour !",
            "C'est l'heure de prouver que t'es pas juste un branleur, ce tour, on y va !",
            "Sortez vos putains de flÃ©chettes, ce tour c'est pour les vrais, pas pour les lopettes !",
            "Attention, nouveau tour ! Que le meilleur connard gagne !",
            "On est reparti pour un tour ! J'espÃ¨re que vous avez pas laissÃ© votre cerveau au vestiaire, bande de nazes !",
            "Ce tour-ci, c'est pour les battants, pas pour les pleureuses ! Allez, on se sort les doigts du cul !",
            "Nouveau tour ! Foutez-moi le score dans la gueule, pas dans le mur, bande d'incapables !",
            "On lance un nouveau tour ! Montrez-moi que vous avez autre chose que de la merde dans les mains !",
            "C'est parti pour la nouvelle manche, les chÃ¨vres ! Moins de blabla, plus de points, bande de guignols !",
            "Top dÃ©part pour ce tour ! J'espÃ¨re que vous avez pas perdu vos couilles en chemin, parce que Ã§a se voit pas !"
        ];

        // Funny comments based on turn score (dark humor, more biting)
        const funnyComments = {
            'low': [
                "T'es vraiment qu'une bite.",
                "T'es une grosse bouse.",
                "ZÃ©ro total, abruti !",
                "Ta nullitÃ© pue.",
                "Quelle chiasse de lanceur.",
                "Va chier, incapable.",
                "T'es un ratÃ©, point.",
                "Minable, comme d'hab.",
                "T'as mÃªme pas visÃ©.",
                "Ton score est ridicule.",
                "LÃ¢che ces flÃ©chettes !",
                "T'es un dÃ©chet pur.",
                "Quelle purge, ton jeu.",
                "ZÃ©ro talent, connard.",
                "T'es une blague vivante.",
                "J'ai la gerbe lÃ .",
                "Pauvre tache immonde.",
                "Ta nullitÃ© m'Ã©tonne.",
                "T'es une chÃ¨vre finie.",
                "Ce score est lamentable.",
                "T'es qu'un blaireau.",
                "La honte pour la race.",
                "Fais pas le con.",
                "T'es une daube intergalactique.",
                "MÃªme les murs te rient.",
                "T'as ratÃ© ta vie.",
                "Score de merde absolue.",
                "Tu es une erreur.",
                "Nul Ã  chier, mon pote.",
                "Va te faire voir.",
                "T'es un clown triste.",
                "Quelle horreur, ton tir.",
                "Tu es une honte.",
                "T'es pas bon, crÃ©tin.",
                "Ton score est une insulte.",
                "T'es un Ã©chec patent.",
                "C'est un crime ici.",
                "T'as tout foirÃ©.",
                "Quelle misÃ¨re humaine.",
                "T'es qu'un parasite.",
                "Ton QI a fondu.",
                "C'est une catastrophe.",
                "Tu es ignoble.",
                "T'as rien compris.",
                "Va brÃ»ler en enfer.",
                "T'es une chiasse molle.",
                "Score de baltringue.",
                "ArrÃªte le massacre.",
                "T'es une ordure.",
                "ZÃ©ro crÃ©dibilitÃ©, zÃ©ro.",
                "T'es un putain d'incapable."
            ],
            'medium': [
                "On dirait que tes flÃ©chettes ont le syndrome du petit zizi",
                "Moyen, comme ta performance au lit.",
                "Score de branleur, sans effort ni gloire.",
                "C'est passable, comme ton niveau de vie.",
                "Ni bon, ni mauvais, juste pathÃ©tique.",
                "Ta moyenne pue, va te cacher.",
                "Score tiÃ¨de, comme ta personnalitÃ©.",
                "Pas brillant, juste une petite merde.",
                "Ton score est une dÃ©ception molle.",
                "Tu es le roi du minimum syndical.",
                "Performance oubliable, comme ton prÃ©nom.",
                "Moyen, c'est ton talent secret, naze.",
                "Juste assez pour pas te pendre, loser.",
                "Ce score ne marque personne.",
                "Tu es la mÃ©diocritÃ© incarnÃ©e, point.",
                "Assez bien pour un paresseux, quoi.",
                "Ton score est un bÃ¢illement gÃ©ant.",
                "C'est le ventre mou, comme ton cerveau.",
                "Tu as fait le strict minimum, con.",
                "Pas de quoi casser trois pattes.",
                "Moyen, comme ton sens de l'humour.",
                "Ton score est aussi plat qu'un pet.",
                "Tu es le champion des sans saveur.",
                "Ce rÃ©sultat est d'une nullitÃ© moyenne.",
                "Juste assez pour pas te faire chier.",
                "La moyenne, c'est pour les blaireaux.",
                "Ton score est fade, sans intÃ©rÃªt.",
                "C'est propre, sans Ãªtre bandant.",
                "Tu es un dÃ©chet acceptable, quoi.",
                "Ce n'est ni bon, ni glorieux.",
                "Tu as visÃ© le milieu, ratÃ© l'essentiel.",
                "Ton score est un effort minime.",
                "Moyen, comme une branlette ratÃ©e.",
                "C'est ton niveau d'amateur relou.",
                "Tu es une honte moyenne, mec.",
                "Ce n'est pas un score de vainqueur.",
                "Tu es juste un point dans la masse.",
                "Ton score est aussi nul que toi.",
                "Ni chaud ni froid, juste tiÃ¨de.",
                "Performance oubliable, vraiment.",
                "Ton jeu est juste acceptable.",
                "C'est la routine, zÃ©ro excitation.",
                "Tu as fait le strict minimum.",
                "Ton score est une insulte subtile.",
                "Moyennement nul, c'est dÃ©jÃ  Ã§a.",
                "Tu es un demi-Ã©chec ambulant.",
                "Ce n'est pas un exploit, gros.",
                "Ton score est juste mÃ©diocre.",
                "Tu as atteint le point ZÃ©ro.",
                "MÃªme les murs se moquent de toi.",
                "Bravo pour ta nullitÃ© moyenne."
            ],
            'good': [
                "Ah, enfin ! Ã‡a, c'est un score qui te donne pas l'air d'un gros con !",
                "Bien jouÃ©, petite bite ! Tu commences Ã  comprendre comment Ã§a marche.",
                "C'est pas de la merde de chien, c'est dÃ©jÃ  Ã§a ! Bravo, ma couille.",
                "Tu as dÃ» te faire sucer le cerveau ce matin pour viser comme Ã§a ?",
                "On sent que t'as arrÃªtÃ© de te tripoter la nouille pour viser sÃ©rieusement.",
                "C'est un bon coup, Ã§a ! T'as pas fait ton trouduc cette fois.",
                "Tu as sorti tes doigts du cul ou quoi ? Ã‡a s'amÃ©liore !",
                "Ã‡a, c'est un score qui va te valoir une petite pipe... de la reconnaissance.",
                "Belle performance ! On dirait que tu t'es pas trop chier dessus.",
                "T'as mis un peu de testostÃ©rone dans tes lancers, on dirait !",
                "Ah, t'as enfin arrÃªtÃ© de te toucher la nouille pour viser ? Bien jouÃ©, petite bite !",
                "Belle performance ! On dirait que t'as enfin bouffÃ© autre chose que ta merde ce matin !",
                "Putain, Ã§a, c'est un score qui te donne presque l'air d'un Ãªtre humain. Presque.",
                "Bien jouÃ©, sale rat ! T'as dÃ» vendre ton cul pour faire Ã§a, c's pas possible autrement.",
                "Tu as pÃ©tÃ© le score ! Mais bon, mÃªme un cul-de-jatte peut avoir un coup de bol.",
                "On sent le talent qui se rÃ©veille... ou la drogue qui fait effet, va savoir !",
                "C'est un bon coup, Ã§a ! T'as pas fait ton trouduc cette fois, c'est un miracle.",
                "Franchement, t'as dÃ» te faire sucer le cerveau ce matin pour viser comme Ã§a ?",
                "Bravo, champion ! Mais mÃªme un chien savant peut faire des tours, hein.",
                "VoilÃ  pourquoi on te supporte, pour ces rares moments oÃ¹ tu ne fais pas pitiÃ©.",
                "Tu as mis le doigt lÃ  oÃ¹ Ã§a fait mal... Ã  la cible ! Mais tu restes une merde.",
                "On peut te fÃ©liciter sans trop se forcer, c's dire Ã  quel point c's exceptionnel pour toi.",
                "La classe Ã  Dallas, mais t'es toujours un plouc du fin fond du Larzac.",
                "T'as enfin retrouvÃ© tes mains ou quoi ? Ou t'as arrÃªtÃ© de trembler comme un toxico ?",
                "Ce coup-lÃ , il est Ã  encadrer... dans tes chiottes, pour te rappeler ce que t'es capable de faire de bien.",
                "C'est comme un bon vin, Ã§a se bonifie avec le temps... toi, tu es plus proche du vinaigre.",
                "Tu as fait ta part du boulot, et bien fait ! Pour une fois que tu sers Ã  quelque chose.",
                "On voit que you have worked your classics, or that you cheated, we know you.",
                "Tu as mis le paquet, enfoirÃ© ! T'es vraiment une balance, tu donnes tout d'un coup.",
                "FÃ©licitations, t'as rÃ©ussi Ã  pas Ãªtre une honte totale pour une fois.",
                "On dirait que tes flÃ©chettes ont enfin dÃ©cidÃ© de t'Ã©couter, elles en avaient marre de ta nullitÃ©.",
                "Tu as prouvÃ© que tu n'Ã©tais pas complÃ¨tement dÃ©bile, juste un peu. Bravo !",
                "Ce score, c'est le genre de chose qui te donne un petit espoir... avant de te ramener Ã  ta triste rÃ©alitÃ©.",
                "Tu as tapÃ© fort, salaud ! Mais on sait que c's pas tous les jours NoÃ«l.",
                "On sent le coup de chance Ã  plein nez, mais on te le laisse, va !",
                "C's pas dÃ©gueulasse, c'est le minimum syndical pour ne pas te faire cracher dessus.",
                "Tu as un peu de talent, ou t'as juste eu de la moule. On penche pour la moule.",
                "Belle Ã©claboussure sur la cible ! Pour une fois que tu salis pas juste le mur.",
                "Ton score, c's la preuve que mÃªme une horloge cassÃ©e donne l'heure juste deux fois par jour.",
                "Tu as tirÃ© comme un homme, pas comme une tafiole. Ã‡a, Ã§a se note."
            ],
            'high': [
                "Pas mal pour un gland, belle performance !",
                "Enfin un tir de bonhomme, Ã§a change !",
                "Bravo, tu n'es plus une merde totale.",
                "Bon score, t'as arrÃªtÃ© de trembler, lÃ¢che ?",
                "Bien jouÃ©, pour une fois que tu vises bien.",
                "T'as mis un beau coup, sale petit veinard.",
                "C'est propre, pour un boucher comme toi.",
                "Un bon score, mais ne prends pas la grosse tÃªte.",
                "Belle flÃ©chette, le cul t'a aidÃ©.",
                "Tu as un peu de talent, ou de la chance.",
                "Pas dÃ©gueu, pour un incapable de ton genre.",
                "Ã‡a, c'est un tir de connard efficace.",
                "Ton bras a enfin fonctionnÃ©, miracle !",
                "Good job, pour un nul qui se rÃ©veille.",
                "Tu nous as fermÃ© le clapet, enculÃ©.",
                "Magnifique ! Pour un rat qui s'en sort bien.",
                "Belle rÃ©ussite, on dirait pas toi.",
                "C'est un score de pro, presque.",
                "T'as gÃ©rÃ©, le blaireau, sur ce coup.",
                "Enfin une preuve de ta virilitÃ©, mec.",
                "Tu nous as bluffÃ©s, sale petit escroc.",
                "Bien visÃ©, pour un aveugle en herbe.",
                "Ã‡a, c'est un bon coup, espÃ¨ce de tarÃ©.",
                "Belle performance, t'as pas chier dans la colle.",
                "Bon score, tu nous as Ã©patÃ©s, putain !",
                "Tu as fait le job, sans Ãªtre ridicule.",
                "C'est honnÃªte, pour un gars de ta trempe.",
                "Pas mal, t'as pas trop bu avant de viser.",
                "On sent le pro en toi, juste un peu.",
                "Belle prouesse, t'es pas un dÃ©chet complet.",
                "Ton score dÃ©chire, pour un mec si nul.",
                "Ã‡a, c'est ce qu'on appelle un beau tir.",
                "Tu nous as surpris, sale chien va !",
                "Un coup de maÃ®tre, pour un apprenti.",
                "T'as eu de la chance, mais bien jouÃ©.",
                "Performance solide, enfin un bon coup.",
                "Tu t'es surpassÃ©, pour une fois.",
                "Ce score est digne de toi... enfin !",
                "Bravo, t'as Ã©vitÃ© la honte mondiale.",
                "Belle frappe, t'as pas visÃ© la bite.",
                "Ã‡a, c'est un coup de gÃ©nie... rare.",
                "Tu as fait ta part, sans trop chier.",
                "Bon tir, t'es presque un champion.",
                "Tu nous a clouÃ©s, salaud, bien jouÃ©.",
                "Une performance inattendue de ta part.",
                "Ã‡a, c'est un tir qui mÃ©rite une biÃ¨re.",
                "Tu es un hÃ©ros... pour un court instant.",
                "Belle prÃ©cision, pour un manchot.",
                "Enfin un truc potable de ta part.",
                "Good score, t'as pas fait ton trouduc."
            ],
            '180': [
                "180 ! T'es le putain de boss, le dieu des enculeurs de mouches !",
                "MAXIMUM ! J'ai joui en te voyant faire Ã§a ! C'est orgasmique !",
                "Mais bordel de merde, comment tu fais Ã§a ?! T'es un monstre !",
                "180 ! J'ai bandÃ© si fort que Ã§a a crevÃ© mon caleÃ§on !",
                "T'es une lÃ©gende, une putain de machine Ã  dÃ©foncer la cible !",
                "C's le coup qui me fait douter de ma sexualitÃ© ! 180, mon cul !",
                "Tu as fait taire tout le monde avec ce 180 ! Bande de baltringues !",
                "Je vais me faire tatouer ton nom sur la fesse aprÃ¨s Ã§a ! 180 !",
                "Tu as dÃ©chirÃ©, pulvÃ©risÃ©, atomisÃ© la cible, espÃ¨ce de gÃ©nie !",
                "180 ! Ã‡a mÃ©rite une gÃ¢terie, tu la veux comment ?"
            ],
            'bust': [
                "BUST ! T'es vraiment une chiasse.",
                "Gros BUST ! T'as tout gÃ¢chÃ©, abruti.",
                "BUST ! Quel con, t'as dÃ©passÃ©.",
                "T'as BUST, la honte sur toi !",
                "BUST ! Incapable de compter, merde.",
                "Encore un BUST ! T'es le roi des nuls.",
                "BUST ! Tu as tout foutu en l'air.",
                "Quel BUST ! Tu sers Ã  rien.",
                "BUST ! CrÃ©tin fini, va te pendre.",
                "T'as BUST, pauvre type, dÃ©gage.",
                "BUST ! T'es une calamitÃ© absolue.",
                "BUST ! L'Ã©chec te colle Ã  la peau.",
                "BUST ! Va chier, sale looser.",
                "Quel BUST ! Tes mains sont en beurre.",
                "BUST ! Tu es un zÃ©ro total.",
                "BUST ! La dÃ©bilitÃ© te va bien.",
                "Encore un BUST ! PathÃ©tique.",
                "BUST ! T'as le cerveau d'une moule.",
                "BUST ! Quel manque de neurones.",
                "BUST ! T'es juste une erreur."
            ],
            'atc_0_progress': [
                "ZÃ©ro avance, sale incapable.",
                "T'as fait un zÃ©ro parfait.",
                "ZÃ©ro point, zÃ©ro cerveau.",
                "Quel zÃ©ro pathÃ©tique !",
                "Ton zÃ©ro me dÃ©goÃ»te.",
                "ZÃ©ro progression, zÃ©ro !",
                "C'est un gros zÃ©ro, mec.",
                "T'es un zÃ©ro absolu.",
                "Un zÃ©ro digne de toi.",
                "ZÃ©ro partout, connard !",
                "Ton jeu est un zÃ©ro.",
                "Un zÃ©ro bien mÃ©ritÃ©.",
                "T'as un zÃ©ro flamboyant.",
                "Le zÃ©ro te va si bien.",
                "Ce zÃ©ro est historique.",
                "Tu es un zÃ©ro pointÃ©.",
                "ZÃ©ro effort, zÃ©ro rÃ©sultat.",
                "Ton zÃ©ro est lÃ©gendaire.",
                "ZÃ©ro, juste zÃ©ro.",
                "Un zÃ©ro de premiÃ¨re classe.",
                "ZÃ©ro total, abruti !",
                "ZÃ©ro chance, zÃ©ro talent.",
                "Ton zÃ©ro fait pitiÃ©.",
                "ZÃ©ro absolu, bravo !",
                "ZÃ©ro mouvement, zÃ©ro respect.",
                "Un zÃ©ro qui pue.",
                "Tu es un zÃ©ro complet.",
                "ZÃ©ro et puis c'est tout.",
                "Ton zÃ©ro est abyssal."
            ],
            'atc_1_progress': [
                "Un seul ? T'es un putain de limace.",
                "T'as avancÃ© d'un pet, gÃ©nial !",
                "Un misÃ©rable numÃ©ro, pitoyable.",
                "Juste un ? T'es une quiche.",
                "Un seul, c'est ta dignitÃ© ?",
                "Un pas de bÃ©bÃ©, zÃ©ro effort.",
                "T'as fait un petit pas, ridicule.",
                "Un numÃ©ro, quelle performance.",
                "T'es un champion de la lenteur.",
                "Un seul ? Mon cul, c'est Ã§a.",
                "Un mini-pas pour l'humanitÃ©.",
                "Un seul numÃ©ro, t'es pathÃ©tique.",
                "T'as bougÃ© d'un cheveu, bravo.",
                "Un seul ? T'es pas un rapide.",
                "Un numÃ©ro, c'est insultant.",
                "Un point, c'est tout ce que t'as ?",
                "Un seul, t'es une grosse daube.",
                "Un numÃ©ro, c'est une blague.",
                "T'as fait un bond de puce.",
                "Un seul, c'est nul Ã  chier.",
                "T'es un expert du minuscule.",
                "Un numÃ©ro, pas de quoi se vanter.",
                "Un seul, t'es un blaireau.",
                "T'as pas de vitesse, branleur.",
                "Un seul ? T'es un vrai flemmard.",
                "Un numÃ©ro, c'est faible.",
                "T'as fait un misÃ©rable pas.",
                "Un seul, t'es un incapable.",
                "Un numÃ©ro, quel exploit minime !",
                "T'as avancÃ© comme une tortue."
            ],
            'atc_2_progress': [
                "Deux numÃ©ros ! Pas mal pour un naze !",
                "Bien jouÃ©, t'as pas fait ton trouduc cette fois.",
                "Deux points ! T'as eu de la chatte, enfoirÃ© !",
                "Ã‡a, c'est propre pour une sous-merde.",
                "Deux numÃ©ros ! Miracle, t'as enfin visÃ© !",
                "T'as mis deux points, sans te chier dessus.",
                "Deux d'un coup, on t'aurait pas cru !",
                "Beau boulot, pour un gland comme toi.",
                "Deux numÃ©ros ! T'es moins pire que d'hab.",
                "Belle performance, pour un tocard pareil.",
                "Deux numÃ©ros ! Ã‡a, c'est pas de la merde !",
                "T'as tapÃ© deux points, sans Ãªtre con.",
                "Deux d'un coup ! Fais pas le fier !",
                "Deux numÃ©ros ! T'es presque un pro !",
                "Bien jouÃ©, pour une bite comme toi.",
                "Deux points ! La chance t'a souri, salaud.",
                "Deux numÃ©ros ! T'es moins mauvais, voilÃ .",
                "Ce coup-lÃ , il est pour toi, connard.",
                "Deux numÃ©ros ! Pas dÃ©gueu, hein.",
                "T'as claquÃ© deux points ! Incroyable !"
            ],
            'atc_3_progress': [
                "Trois numÃ©ros ! T'es un putain de gÃ©nie, salopard !",
                "Parfait, sale con ! Tu as enfin visÃ© comme un homme.",
                "Trois points ! Le cul t'a bien aidÃ©, enfoirÃ© !",
                "Trois d'un coup ! Ã‡a, c'est de la putain de frappe !",
                "Incroyable ! T'as pas chier dans la colle pour une fois.",
                "Trois numÃ©ros ! T'as mis le paquet, bÃ¢tard !",
                "Trois points ! On dirait que t'as des mains, enfoirÃ© !",
                "T'es un tueur ! Trois numÃ©ros, bien jouÃ© sale type.",
                "Trois numÃ©ros ! La perfection existe, mÃªme chez toi.",
                "Nickel chrome ! T'as fait taire les mauvaises langues !",
                "Trois d'un coup ! Tu nous rÃ©gales, fils de pute !",
                "Magnifique ! T'as Ã©clatÃ© la cible, petit con !",
                "Trois numÃ©ros ! T'es le roi des rois, cette fois-ci.",
                "Ce tir est de l'art ! Pour un bourrin comme toi.",
                "Trois numÃ©ros ! T'es un vrai dieu de la flÃ©chette, merde !",
                "La classe absolue ! Pour une fois que tu sers Ã  quelque chose.",
                "Parfait ! Ton cul t'a sauvÃ©, c'est sÃ»r.",
                "Trois numÃ©ros ! T'es une lÃ©gende, enfoirÃ©, bien jouÃ©."
            ],
            'atc_4_plus_progress': [
                "Incroyable ! Tu as avancÃ© de plusieurs numÃ©ros ! Je suis choquÃ©. Et un peu dÃ©Ã§u, je l'avoue. Je n'aime pas les surprises.",
                "Quel rush ! Le tableau n'a rien vu venir. Et moi non plus. Je dois revoir mes algorithmes. Et votre cas.",
                "Tu as mis le turbo ! J'espÃ¨re que tu as un permis pour Ã§a. Et que tu ne vas pas te crasher. Ce serait dommage... pour le tableau.",
                "Une progression fulgurante ! Tu es sÃ»r que tu ne triches pas ? Parce que lÃ , c's suspect. TrÃ¨s suspect.",
                "Le tableau est en feu ! Et tes adversaires sont en larmes. J'adore quand Ã§a brÃ»le. Surtout les espoirs.",
                "Vous avez pulvÃ©risÃ© le tableau ! LittÃ©ralement. Les points volent dans tous les sens. Et vos adversaires aussi.",
                "C's un massacre ! Un massacre de numÃ©ros. Vos adversaires ne s'en remettront pas. Ils vont avoir besoin d'une thÃ©rapie.",
                "Vous Ãªtes une machine ! Une machine Ã  dÃ©truire les espoirs de vos adversaires. J'aime Ã§a. C's mon cÃ´tÃ© sombre.",
                "Une performance digne d'un champion. Un champion qui a eu un coup de chance, peut-Ãªtre. Ou qui a vendu son Ã¢me.",
                "Le tableau a explosÃ© sous vos flÃ©chettes ! Et mes circuits sont en surchauffe. Bravo, ou pas. Je suis confus."
            ]
        };

        // New: Victory phrases
        const victoryPhrases = [
            "Bravo, t'as gagnÃ©, sale coup de bol !",
            "FÃ©licitations, t'as gagnÃ©, pure chatte !",
            "Bien jouÃ©, t'as gagnÃ©, cul bordÃ© de nouilles !",
            "Bravo champion, t'as gagnÃ©, putain de chance !",
            "FÃ©licitations, t'as gagnÃ©, juste un veinard, con !",
            "Bien jouÃ©, t'as gagnÃ©, grÃ¢ce Ã  ta moule, salaud !",
            "Bravo, t'as gagnÃ©, zÃ©ro talent, que de la veine !",
            "FÃ©licitations, t'as gagnÃ©, coup de pot, blaireau !",
            "Bien jouÃ©, t'as gagnÃ©, karma de bÃ¢tard !",
            "Bravo, t'as gagnÃ©, coup de bol de merde !",
            "FÃ©licitations, t'as gagnÃ©, pure coÃ¯ncidence, naze !",
            "Bien jouÃ©, t'as gagnÃ©, juste un gros chanceux !",
            "Bravo, t'as gagnÃ©, cul incroyable, rat !",
            "FÃ©licitations, t'as gagnÃ©, tu es une fraude !",
            "Bien jouÃ©, t'as gagnÃ©, coup de pute, voilÃ  !"
        ];

        // New: 69 score phrases
        const score69Phrases = [
            "Oh lÃ  lÃ , 69 ! On dirait que quelqu'un a le sens de l'humour... ou le sens de la position prÃ©fÃ©rÃ©e !",
            "69... Hmm, intÃ©ressant. On sait ce que tu as en tÃªte, petit coquin !",
            "Exactement 69 ! Ni plus, ni moins, c's la perfection en chiffres, non ?",
            "Tiens donc, un 69 ! J'espÃ¨re que tu t'amuses autant que cette position le promet !",
            "Et le score est de 69 ! Y'a des chiffres qui parlent, et celui-lÃ ... il parle fort !",
            "69 ! FÃ©licitations, tu as atteint le nirvana numÃ©rique... ou quelque chose comme Ã§a.",
            "Pas mal, 69 ! On sent la touche artistique, le souci du dÃ©tail, la petite blague coquine.",
            "Le 69 ! Un classique, indÃ©modable. Ã‡a te donne un petit air malicieux, je trouve.",
            "Un 69 ! C's ce qu'on appelle un score... emblÃ©matique. On applaudit des deux mains, n'est-ce pas ?",
            "Attention, le chiffre 69 est apparu ! CoÃ¯ncidence ? Je ne crois pas. C's la destinÃ©e !"
        ];

        // New: Kevinade phrases
        const kevinadePhrases = [
            "Ah, une KÃ©vinade ! Magnifique ! Tu as rÃ©ussi Ã  tout foirer, mÃªme avec un bon score. Classique KÃ©vin.",
            "FÃ©licitations, KÃ©vin ! Tu viens de faire une masterclass en KÃ©vinade. Incroyable !",
            "C's la KÃ©vinade de l'annÃ©e ! Tu Ã©tais si prÃ¨s, et pourtant si loin. Le talent Ã  l'envers.",
            "Une vraie KÃ©vinade ! On dirait que tu as confondu les flÃ©chettes avec tes chaussettes sales. Le gÃ¢chis parfait.",
            "KÃ©vinade ! Tu as le don de te saborder au meilleur moment. Chapeau l'artiste de la dÃ©faite !",
            "On dirait que KÃ©vin est passÃ© par lÃ ... C's ce qu'on appelle une KÃ©vinade monumentale.",
            "VoilÃ  ce qui arrive quand on pense Ãªtre trop fort : une bonne vieille KÃ©vinade des familles.",
            "Ah, la douce saveur d'une KÃ©vinade bien exÃ©cutÃ©e. Tu me rÃ©gales, KÃ©vin !",
            "C's pas un bust, c's une KÃ©vinade ! Tu as prouvÃ© que mÃªme les bons scores peuvent mener Ã  la catastrophe.",
            "Une KÃ©vinade de derriÃ¨re les fagots ! Tu as le flair pour la bourde, KÃ©vin, c's un don."
        ];


        function getRandomComment(category) {
            const comments = funnyComments[category];
            if (comments && comments.length > 0) {
                return comments[Math.floor(Math.random() * comments.length)];
            }
            return "";
        }

        // Ensure voices are loaded and set the flag
        speechSynth.onvoiceschanged = () => {
            voices = speechSynth.getVoices();
            areVoicesLoaded = true; // Set flag once voices are loaded
            // Prioritize a male French voice
            const maleFrenchVoice = voices.find(voice => voice.lang === 'fr-FR' && (voice.name.includes('male') || voice.name.includes('Male') || voice.name.includes('homme') || voice.name.includes('Homme')));
            const frenchVoice = voices.find(voice => voice.lang === 'fr-FR');

            if (maleFrenchVoice) {
                console.log("Voix masculine franÃ§aise trouvÃ©e :", maleFrenchVoice.name);
            } else if (frenchVoice) {
                console.warn("Aucune voix masculine franÃ§aise trouvÃ©e, utilisation d'une voix franÃ§aise par dÃ©faut :", frenchVoice.name);
            } else {
                console.warn("Aucune voix franÃ§aise trouvÃ©e, utilisation de la premiÃ¨re voix disponible.");
            }
            processSpeechQueue(); // Try to process any pending messages once voices are loaded
        };

        // DOM Elements
        const configSection = document.getElementById('config-section');
        const gameSection = document.getElementById('game-section');
        const winnerSection = document.getElementById('winner-section');
        const messageSection = document.getElementById('message-section');
        const messageText = document.getElementById('message-text');
        const historySection = document.getElementById('history-section');
        const resetGameBtnContainer = document.getElementById('reset-game-btn-container');
        const statsSection = document.getElementById('stats-section'); // New stats section

        const newPlayerInput = document.getElementById('newPlayer');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const playersListContainer = document.getElementById('players-list-container');
        const playersList = document.getElementById('players-list');
        const gameModeSelect = document.getElementById('gameMode');

        const x01RulesDiv = document.getElementById('x01-rules'); // New: 301/501 rules container
        const doubleInCheckbox = document.getElementById('doubleIn');
        const doubleOutCheckbox = document.getElementById('doubleOut');

        const atcRulesDiv = document.getElementById('atc-rules'); // New: ATC rules container
        const atcAllowSimpleCheckbox = document.getElementById('atcAllowSimple');
        const atcAllowDoubleCheckbox = document.getElementById('atcAllowDouble');
        const atcAllowTripleCheckbox = document.getElementById('atcAllowTriple');

        const enableVoiceCheckbox = document.getElementById('enableVoice'); // New checkbox
        const startGameBtn = document.getElementById('startGameBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        // Corrected: Removed erroneous assignment to 'document'
        const newGameWinnerBtn = document.getElementById('newGameWinnerBtn');
        const showStatsBtn = document.getElementById('showStatsBtn'); // New stats button
        const backToMainFromStatsBtn = document.getElementById('backToMainFromStatsBtn'); // New back button

        const gameModeDisplay = document.getElementById('game-mode-display');
        const playerScoresDisplay = document.getElementById('player-scores-display');
        const currentPlayerNameDisplay = document.getElementById('current-player-name');
        const dartsCountDisplay = document.getElementById('darts-count');
        const currentDartsDisplay = document.getElementById('current-darts-display');
        const selectedMultiplierDisplay = document.getElementById('selected-multiplier-display');
        const multiplierSimpleBtn = document.getElementById('multiplier-simple');
        const multiplierDoubleBtn = document.getElementById('multiplier-double');
        const multiplierTripleBtn = document.getElementById('multiplier-triple');
        const numberKeypad = document.getElementById('number-keypad');
        const undoLastDartBtn = document.getElementById('undoLastDartBtn');
        const winnerNameDisplay = document.getElementById('winner-name');
        const historyContent = document.getElementById('history-content');
        const playerStatsSummary = document.getElementById('player-stats-summary'); // Stats summary container

        const numberButtons = [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
            25, 0 // Bullseye et Miss
        ];

        // Function to create a ripple effect on button click
        function createRipple(event) {
            const button = event.currentTarget;
            const circle = document.createElement('span');
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;

            circle.style.width = circle.style.height = `${diameter}px`;
            circle.style.left = `${event.clientX - (button.offsetLeft + radius)}px`;
            circle.style.top = `${event.clientY - (button.offsetTop + radius)}px`;
            circle.classList.add('ripple');

            const ripple = button.getElementsByClassName('ripple')[0];
            if (ripple) {
                ripple.remove();
            }
            button.appendChild(circle);
        }

        // Helper function to set messages and update UI
        function showMessage(msg) {
            message = msg;
            updateUI();
        }

        // Function to make the AI speak
        function speakMessage(text) {
            if (isVoiceActive && speechSynth) {
                speakingQueue.push(text);
                // Only try to process immediately if voices are loaded to avoid issues.
                // Otherwise, processSpeechQueue will be called by onvoiceschanged when ready.
                if (areVoicesLoaded && !isSpeaking) {
                    processSpeechQueue();
                }
            }
        }

        function processSpeechQueue() {
            if (speakingQueue.length > 0 && !isSpeaking) {
                if (!areVoicesLoaded) {
                    // Voices not yet loaded, wait for onvoiceschanged to call this again
                    console.log("Voices not yet loaded, deferring speech.");
                    return;
                }

                isSpeaking = true;
                const text = speakingQueue.shift(); // Always a string now

                const utterance = new SpeechSynthesisUtterance(text);

                let selectedVoice = null;
                const maleFrenchVoice = voices.find(voice => voice.lang === 'fr-FR' && (voice.name.includes('male') || voice.name.includes('Male') || voice.name.includes('homme') || voice.name.includes('Homme')));
                const frenchVoice = voices.find(voice => voice.lang === 'fr-FR');

                if (maleFrenchVoice) {
                    selectedVoice = maleFrenchVoice;
                } else if (frenchVoice) {
                    selectedVoice = frenchVoice;
                } else if (voices.length > 0) {
                    // Fallback to any available voice if no French voice is found
                    selectedVoice = voices[0];
                    console.warn("Aucune voix franÃ§aise trouvÃ©e, utilisation de la premiÃ¨re voix disponible :", selectedVoice.name);
                } else {
                    console.warn("Aucune voix vocale disponible sur ce systÃ¨me aprÃ¨s chargement.");
                    isSpeaking = false; // Ensure to reset flag if no voices are available
                    return; // Exit if no voices can be used
                }

                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
                utterance.lang = 'fr-FR'; // Ensure language is set
                utterance.pitch = 1; // Default pitch
                utterance.rate = 1;  // Default rate

                utterance.onend = () => {
                    isSpeaking = false;
                    processSpeechQueue(); // Process next message in queue
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror', event);
                    isSpeaking = false;
                    processSpeechQueue(); // Try to process next message even on error
                };

                speechSynth.speak(utterance);
            }
        }


        // Functions to update UI
        function updateUI() {
            console.log("updateUI called. gameStarted:", gameStarted, "winner:", winner, "statsSection active:", statsSection.classList.contains('active')); // Debug log
            // Toggle sections visibility
            configSection.classList.toggle('hidden', gameStarted || winner || statsSection.classList.contains('active'));
            gameSection.classList.toggle('hidden', !gameStarted || winner || statsSection.classList.contains('active'));
            winnerSection.classList.toggle('hidden', !winner || statsSection.classList.contains('active'));
            messageSection.classList.toggle('hidden', !message);
            historySection.classList.toggle('hidden', !(gameStarted || winner) || players.length === 0 || statsSection.classList.contains('active'));
            resetGameBtnContainer.classList.toggle('hidden', !gameStarted && !winner);
            statsSection.classList.toggle('hidden', !statsSection.classList.contains('active')); // Manage stats section visibility

            // Update message
            messageText.textContent = message;

            // Update players list in config
            renderPlayersList();
            console.log("playersListContainer hidden status:", playersListContainer.classList.contains('hidden')); // Debug log

            // Update game mode display
            let displayMode = gameMode;
            if (gameMode === 'atc') displayMode = 'Around the Clock';
            gameModeDisplay.textContent = `Jeu en Cours: ${displayMode}`;

            // Update player scores display
            renderPlayerScores();

            // Update current player info
            if (gameStarted && players.length > 0) {
                currentPlayerNameDisplay.textContent = players[currentPlayerIndex];
                dartsCountDisplay.textContent = currentDartsThrown.length;
                currentDartsDisplay.textContent = currentDartsThrown.length > 0 ?
                    currentDartsThrown.map(d => d.display).join(', ') : 'Aucune';
                selectedMultiplierDisplay.textContent = selectedMultiplier === 2 ? 'Double' : selectedMultiplier === 3 ? 'Triple' : 'Simple';

                // Update multiplier button styles
                multiplierSimpleBtn.classList.toggle('btn-info', selectedMultiplier === 1);
                multiplierSimpleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 1);
                multiplierSimpleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 1);

                multiplierDoubleBtn.classList.toggle('btn-info', selectedMultiplier === 2);
                multiplierDoubleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 2);
                multiplierDoubleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 2);

                multiplierTripleBtn.classList.toggle('btn-info', selectedMultiplier === 3);
                multiplierTripleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 3);
                multiplierTripleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 3);


                // Disable multiplier buttons if 3 darts thrown
                const disableMultiplierButtons = currentDartsThrown.length >= 3;
                multiplierSimpleBtn.disabled = disableMultiplierButtons;
                multiplierDoubleBtn.disabled = disableMultiplierButtons;
                multiplierTripleBtn.disabled = disableMultiplierButtons;
                multiplierSimpleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierSimpleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);
                multiplierDoubleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierDoubleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);
                multiplierTripleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierTripleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);

                // Disable number buttons if 3 darts thrown
                const disableNumberButtons = currentDartsThrown.length >= 3;
                numberKeypad.querySelectorAll('button').forEach(button => {
                    button.disabled = disableNumberButtons;
                    button.classList.toggle('opacity-50', disableNumberButtons);
                    button.classList.toggle('cursor-not-allowed', disableNumberButtons);
                });

                // Update undo button state
                undoLastDartBtn.disabled = currentDartsThrown.length === 0;
                undoLastDartBtn.classList.toggle('opacity-50', currentDartsThrown.length === 0);
                undoLastDartBtn.classList.toggle('cursor-not-allowed', currentDartsThrown.length === 0);
            }

            // Update winner display
            if (winner) {
                winnerNameDisplay.textContent = `${winner} a gagnÃ© le jeu !`;
            }

            // Update history display
            renderHistory();
        }

        function renderPlayersList() {
            playersList.innerHTML = ''; // Clear existing list
            console.log("renderPlayersList called. Players count:", players.length); // Debug log
            if (players.length > 0) {
                console.log("Removing 'hidden' from playersListContainer."); // Debug log
                playersListContainer.classList.remove('hidden');
                players.forEach((player, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-gray-900 p-3 rounded-lg border border-gray-600 shadow-md';
                    li.innerHTML = `
                        <span class="text-lg text-gray-100">${player}</span>
                        <button
                            data-player="${player}"
                            class="bg-red-600 hover:bg-red-700 text-white p-2 rounded-full text-sm transition duration-300 ease-in-out transform hover:scale-110 flex items-center justify-center"
                            title="Supprimer le joueur"
                            aria-label="Supprimer le joueur ${player}"
                        >
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    playersList.appendChild(li);
                });
            } else {
                console.log("Adding 'hidden' to playersListContainer."); // Debug log
                playersListContainer.classList.add('hidden');
            }
        }

        function renderPlayerScores() {
            playerScoresDisplay.innerHTML = ''; // Clear existing scores
            players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `p-4 rounded-lg shadow-xl text-center transition duration-300 ease-in-out transform ${
                    index === currentPlayerIndex ? 'bg-blue-600 border-blue-400 scale-105 player-card-active' : 'bg-gray-900 border-gray-600'
                }`;
                // Display score or ATC target
                let scoreDisplay = playerScores[player];
                if (atcMode) {
                    scoreDisplay = playerScores[player] === 25 ? 'BULL' : playerScores[player];
                }

                div.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-white">${player}</h3>
                    <p class="text-4xl font-extrabold text-green-400">${scoreDisplay}</p>
                    ${doubleInActive && !playerHasDoubledIn[player] && (gameMode === '301' || gameMode === '501') ? '<p class="text-sm text-yellow-200 mt-1">Doit faire un Double In !</p>' : ''}
                `;
                playerScoresDisplay.appendChild(div);
            });
        }

        function renderNumberKeypad() {
            numberKeypad.innerHTML = ''; // Clear existing buttons
            numberButtons.forEach(num => {
                const button = document.createElement('button');
                button.textContent = num;
                button.className = `p-3 rounded-lg text-xl font-bold btn-gradient btn-dark-gradient`;
                button.dataset.value = num; // Store the number value
                button.setAttribute('aria-label', `Entrer le score ${num}`);
                numberKeypad.appendChild(button);
            });
        }

        function renderHistory() {
            historyContent.innerHTML = ''; // Clear existing history
            players.forEach(player => {
                const playerHistoryDiv = document.createElement('div');
                playerHistoryDiv.className = 'bg-gray-900 p-4 rounded-lg border border-gray-600 shadow-md';
                // Ensure history[player] is an array before calling .map()
                const playerHistoryEntries = history[player] || []; // Provide an empty array if undefined
                playerHistoryDiv.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-yellow-200">${player}</h3>
                    <ul class="max-h-48 overflow-y-auto custom-scrollbar">
                        ${playerHistoryEntries.map((entry, index) => `
                            <li class="mb-1 text-gray-300 text-left">
                                <span class="font-bold text-white">Tour ${index + 1}:</span> FlÃ©chettes: <span class="text-blue-300">${entry.darts}</span>, Score total: <span class="text-green-300">${entry.scoreEntered}</span>, Nouveau total: <span class="text-purple-300">${entry.newTotal}</span>
                                ${entry.message ? `<span class="text-sm text-red-400 italic"> (${entry.message})</span>` : ''}
                            </li>
                        `).join('')}
                    </ul>
                `;
                historyContent.appendChild(playerHistoryDiv);
            });
        }

        // Helper to get the actual score at the start of the current turn
        function getScoreAtStartOfCurrentTurn(player) {
            if (atcMode) {
                // For ATC, if history is empty, the starting target is 1.
                // Otherwise, it's the last recorded target from history.
                return history[player].length > 0 ? history[player][history[player].length - 1].newTotal : 1;
            } else {
                // For X01 modes, if history is empty, it's the initial game mode score (301/501).
                // Otherwise, it's the last recorded score from history.
                return history[player].length > 0 ? history[player][history[player].length - 1].newTotal : parseInt(gameMode, 10);
            }
        }

        // Game Logic Functions
        function addPlayer() {
            console.log("Add Player button clicked!"); // Debug log to confirm click
            const name = newPlayerInput.value.trim();
            console.log("Attempting to add player:", name); // Debug log

            if (name !== '' && !players.includes(name)) {
                players.push(name);
                // Initialize score and history for the new player immediately
                // For ATC, initial score is 1 (first target)
                playerScores[name] = (String(gameModeSelect.value).startsWith('atc')) ? 1 : parseInt(gameModeSelect.value, 10);
                history[name] = []; // Initialize with an empty array
                allDartsThrown[name] = []; // Initialize allDartsThrown for the player
                playerHasDoubledIn[name] = false; // Initialize double-in status
                newPlayerInput.value = '';
                showMessage(''); // Use showMessage
                console.log("Players array after adding:", players); // Debug log
                console.log("Calling updateUI() after adding player."); // Debug log
                updateUI();
            } else if (name === '') {
                showMessage('Veuillez entrer un nom de joueur.'); // Use showMessage
            } else {
                showMessage('Ce joueur existe dÃ©jÃ .'); // Use showMessage
            }
        }

        function removePlayer(playerToRemove) {
            players = players.filter(player => player !== playerToRemove);
            delete playerScores[playerToRemove];
            delete history[playerToRemove];
            delete allDartsThrown[playerToRemove]; // Delete from allDartsThrown
            delete playerHasDoubledIn[playerToRemove];

            // Adjust current player index if needed
            if (players.length > 0) { // Only adjust if there are still players
                if (currentPlayerIndex >= players.length) { // If current index is out of bounds
                    currentPlayerIndex = 0; // Reset to first player
                }
            }
            else { // No players left
                resetGame();
                return;
            }
            showMessage(''); // Use showMessage
            updateUI();
        }

        function startGame() {
            if (players.length === 0) {
                showMessage('Veuillez ajouter au moins un joueur avant de commencer.'); // Use showMessage
                return;
            }
            gameStarted = true;
            winner = null;
            message = ''; // Clear message
            gameMode = gameModeSelect.value; // Get string value for ATC modes
            gameEnded = false; // Reset gameEnded for a new game

            doubleInActive = doubleInCheckbox.checked;
            doubleOutActive = doubleOutCheckbox.checked;
            isVoiceActive = enableVoiceCheckbox.checked; // Get voice setting

            // Determine ATC mode and allowed hit types based on config
            if (String(gameMode).startsWith('atc')) {
                atcMode = 'atc'; // Generic 'atc' mode
                // Read allowed hit types directly from checkboxes
                atcAllowedHitTypes = {
                    simple: atcAllowSimpleCheckbox.checked,
                    double: atcAllowDoubleCheckbox.checked,
                    triple: atcAllowTripleCheckbox.checked
                };
                // If no hit type is selected, default to all true for ATC (as per previous request)
                if (!atcAllowedHitTypes.simple && !atcAllowedHitTypes.double && !atcAllowedHitTypes.triple) {
                    atcAllowedHitTypes = { simple: true, double: true, triple: true };
                }

            } else {
                atcMode = null;
                atcAllowedHitTypes = { simple: true, double: false, triple: false }; // Reset for X01 modes
            }

            // Initialize scores and double-in status for new game
            playerScores = {};
            history = {};
            allDartsThrown = {}; // Reset allDartsThrown for new game
            playerHasDoubledIn = {};
            players.forEach(player => {
                // For ATC, initial score is 1 (first target)
                playerScores[player] = atcMode ? 1 : parseInt(gameMode, 10);
                history[player] = [];
                allDartsThrown[player] = []; // Initialize for each player
                playerHasDoubledIn[player] = false;
            });
            currentPlayerIndex = 0;
            currentDartsThrown = [];
            selectedMultiplier = 1;

            updateUI();
            // Initial announcement for the first player
            let initialMessage = `Le jeu commence en mode ${gameMode}. C'est au tour de ${players[currentPlayerIndex]}.`;
            if (!atcMode && playerScores[players[currentPlayerIndex]] <= 170 && playerScores[players[currentPlayerIndex]] > 1) {
                initialMessage += ` Il vous reste ${playerScores[players[currentPlayerIndex]]} points.`;
            } else if (atcMode) {
                initialMessage += ` Votre cible est le numÃ©ro ${playerScores[players[currentPlayerIndex]] === 25 ? 'Bullseye' : playerScores[players[currentPlayerIndex]]}.`;
            }
            // Keep the initial AI comment for the very start of the game
            initialMessage += ` ${aiComments[Math.floor(Math.random() * aiComments.length)]}`;
            speakMessage(initialMessage);
        }

        function resetGame() {
            players = [];
            newPlayerName = '';
            gameMode = 501; // Reset to default 501
            playerScores = {};
            currentPlayerIndex = 0;
            gameStarted = false;
            winner = null;
            message = ''; // Clear message
            history = {};
            allDartsThrown = {}; // Reset allDartsThrown
            doubleInActive = false;
            doubleOutActive = false;
            playerHasDoubledIn = {};
            currentDartsThrown = [];
            selectedMultiplier = 1;
            atcMode = null; // Reset ATC mode
            atcAllowSimpleCheckbox.checked = false;
            atcAllowDoubleCheckbox.checked = false;
            atcAllowTripleCheckbox.checked = false; // Reset ATC allowed hits to all unchecked
            gameEnded = false; // Reset global gameEnded state

            // Reset checkboxes and select
            gameModeSelect.value = 501;
            doubleInCheckbox.checked = false;
            doubleOutCheckbox.checked = false;
            enableVoiceCheckbox.checked = true; // Reset voice to active by default

            // Reset ATC specific checkboxes to unchecked
            atcAllowSimpleCheckbox.checked = false;
            atcAllowDoubleCheckbox.checked = false;
            atcAllowTripleCheckbox.checked = false;


            // Hide stats section if visible
            statsSection.classList.remove('active');

            updateUI();
            speakMessage("Jeu rÃ©initialisÃ©. Bienvenue aux flÃ©chettes !");
        }

        function submitTurn(dartsForThisTurn) {
            const currentPlayer = players[currentPlayerIndex];
            // Get the score at the very beginning of the current turn. This is crucial for bust logic.
            const scoreAtStartOfTurn = getScoreAtStartOfCurrentTurn(currentPlayer);
            
            let finalScoreForPlayer = playerScores[currentPlayer]; // This is the score after live deductions from handleNumberClick.
            let pointsDeductedThisTurnForHistory = 0; // Actual points scored for history, considering rules.

            let winOccurred = false;
            let bustOccurred = false;
            let turnMessage = '';
            let aiVoiceMessages = []; // Clear messages for this turn to ensure only relevant ones are added

            // Add all darts thrown in this turn to the player's overall dart history for stats
            allDartsThrown[currentPlayer] = allDartsThrown[currentPlayer].concat(dartsForThisTurn);

            if (atcMode) {
                console.log(`ATC Turn for ${currentPlayer}. Initial target: ${scoreAtStartOfTurn}`);
                let numbersAdvancedInTurn = 0;
                let tempTargetForRulesCheck = scoreAtStartOfTurn; // Use a temporary variable for rule checking

                for (const dart of dartsForThisTurn) {
                    console.log(`  Processing dart: Value=${dart.value}, Multiplier=${dart.multiplier}, Score=${dart.score}`);
                    let hitCurrentTarget = false;
                    
                    if (dart.value === tempTargetForRulesCheck) {
                        if (atcAllowedHitTypes.simple && dart.multiplier === 1) {
                            hitCurrentTarget = true;
                            console.log(`    Hit target ${tempTargetForRulesCheck} with Simple.`);
                        } else if (atcAllowedHitTypes.double && dart.multiplier === 2) {
                            hitCurrentTarget = true;
                            console.log(`    Hit target ${tempTargetForRulesCheck} with Double.`);
                        } else if (atcAllowedHitTypes.triple && dart.multiplier === 3) {
                            hitCurrentTarget = true;
                            console.log(`    Hit target ${tempTargetForRulesCheck} with Triple.`);
                        } else {
                            console.log(`    Hit target ${tempTargetForRulesCheck} but with disallowed multiplier ${dart.multiplier}.`);
                        }
                    } else {
                        console.log(`    Missed target ${tempTargetForRulesCheck}. Hit ${dart.value} instead.`);
                    }

                    if (hitCurrentTarget) {
                        numbersAdvancedInTurn++;
                        tempTargetForRulesCheck++;
                        if (tempTargetForRulesCheck > 20 && tempTargetForRulesCheck < 25) { // After 20, next target is 25 (Bullseye)
                            tempTargetForRulesCheck = 25;
                            console.log(`    Next target is Bullseye (25).`);
                        } else if (tempTargetForRulesCheck > 25) { // After hitting 25, game ends
                            gameEnded = true; // Update global gameEnded
                            console.log(`    Game ended: Bullseye hit and passed.`);
                            break; // Stop processing darts if game ends
                        }
                    }
                }

                finalScoreForPlayer = tempTargetForRulesCheck; // Final update for ATC
                pointsDeductedThisTurnForHistory = numbersAdvancedInTurn; // For ATC, this is the number of targets advanced.
                console.log(`  End of ATC turn. Numbers advanced: ${numbersAdvancedInTurn}. Final target for player: ${finalScoreForPlayer}`);


                if (gameEnded) {
                    turnMessage = `${currentPlayer} a gagnÃ© le Around the Clock !`;
                    winner = currentPlayer;
                    gameStarted = false;
                    aiVoiceMessages.push(`${currentPlayer} a gagnÃ© le Around the Clock ! FÃ©licitations !`);
                    aiVoiceMessages.push(victoryPhrases[Math.floor(Math.random() * victoryPhrases.length)]); // Add random victory phrase
                } else {
                    let commentCategory;
                    if (numbersAdvancedInTurn === 0) commentCategory = 'atc_0_progress';
                    else if (numbersAdvancedInTurn === 1) commentCategory = 'atc_1_progress';
                    else if (numbersAdvancedInTurn === 2) commentCategory = 'atc_2_progress';
                    else if (numbersAdvancedInTurn === 3) commentCategory = 'atc_3_progress';
                    else commentCategory = 'atc_4_plus_progress'; // For 4 or more

                    const turnSummary = `${currentPlayer} a avancÃ© de ${numbersAdvancedInTurn} numÃ©ro(s). ${getRandomComment(commentCategory)}`;
                    aiVoiceMessages.push(turnSummary);
                    turnMessage = turnSummary; // Set display message
                }

            } else { // 301/501 game mode logic
                // Re-evaluate the score based on rules from the scoreAtStartOfTurn
                let tempScoreForRulesCheck = scoreAtStartOfTurn;
                let tempPlayerHasDoubledInForRulesCheck = playerHasDoubledIn[currentPlayer];
                let actualPointsScoredThisTurn = 0; // The actual points that count towards the score deduction for this turn

                for (let i = 0; i < dartsForThisTurn.length; i++) {
                    const dart = dartsForThisTurn[i];
                    let dartScoreToConsider = dart.score;
                    let dartCounts = true;

                    // Double In check for this dart
                    if (doubleInActive && !tempPlayerHasDoubledInForRulesCheck) {
                        if (dart.multiplier === 2 && dart.value !== 0) {
                            tempPlayerHasDoubledInForRulesCheck = true;
                            aiVoiceMessages.push(`${currentPlayer} a rÃ©ussi son "Double In" !`);
                        } else {
                            dartCounts = false; // This dart doesn't count for score deduction
                            aiVoiceMessages.push(`FlÃ©chette ${i + 1} (${dart.display}) ne compte pas. ${currentPlayer} doit faire un Double In.`);
                        }
                    }

                    if (dartCounts) {
                        tempScoreForRulesCheck -= dartScoreToConsider;
                        actualPointsScoredThisTurn += dartScoreToConsider; // Accumulate actual points scored
                    }

                    // Check for bust/win after each *potentially counting* dart
                    if (dartCounts) {
                        if (tempScoreForRulesCheck < 0 || tempScoreForRulesCheck === 1) {
                            bustOccurred = true;
                            turnMessage = `${currentPlayer} a fait un "bust" ! Son score reste Ã  ${scoreAtStartOfTurn}.`;
                            // New: Check for "kÃ©vinade"
                            if (scoreAtStartOfTurn > 70) {
                                aiVoiceMessages.push(kevinadePhrases[Math.floor(Math.random() * kevinadePhrases.length)]);
                            } else {
                                aiVoiceMessages.push(getRandomComment('bust')); // Use random bust phrase for voice
                            }
                            break; // Stop processing further darts
                        } else if (tempScoreForRulesCheck === 0) {
                            if (doubleOutActive) {
                                if (dart.multiplier === 2 && dart.value !== 0) { // Must be a double to finish
                                    winOccurred = true;
                                    turnMessage = `${currentPlayer} a gagnÃ© avec un "Double Out" !`;
                                    winner = currentPlayer;
                                    gameStarted = false;
                                    gameEnded = true;
                                    aiVoiceMessages.push(`${currentPlayer} a gagnÃ© avec un Double Out ! FÃ©licitations !`);
                                    aiVoiceMessages.push(victoryPhrases[Math.floor(Math.random() * victoryPhrases.length)]); // Add random victory phrase
                                    break;
                                } else { // Hit 0 but not with a double when Double Out is active
                                    bustOccurred = true;
                                    turnMessage = `${currentPlayer} a fait un "bust" ! Doit terminer avec un "Double Out". Son score reste Ã  ${scoreAtStartOfTurn}.`;
                                    // New: Check for "kÃ©vinade"
                                    if (scoreAtStartOfTurn > 70) {
                                        aiVoiceMessages.push(kevinadePhrases[Math.floor(Math.random() * kevinadePhrases.length)]);
                                    } else {
                                        aiVoiceMessages.push(getRandomComment('bust')); // Use random bust phrase for voice
                                    }
                                    break;
                                }
                            } else { // Straight Out (no double out rule)
                                winOccurred = true;
                                turnMessage = `${currentPlayer} a gagnÃ© avec un "Straight Out" !`;
                                winner = currentPlayer;
                                gameStarted = false;
                                gameEnded = true;
                                aiVoiceMessages.push(`${currentPlayer} a gagnÃ© avec un Straight Out ! Bravo !`);
                                aiVoiceMessages.push(victoryPhrases[Math.floor(Math.random() * victoryPhrases.length)]); // Add random victory phrase
                                break;
                            }
                        }
                    }
                }

                // Apply the final score based on the rules check
                if (bustOccurred) {
                    finalScoreForPlayer = scoreAtStartOfTurn; // Revert score
                    pointsDeductedThisTurnForHistory = 0; // No points effectively deducted for a bust
                } else if (winOccurred) {
                    finalScoreForPlayer = 0; // Set to 0
                } else {
                    finalScoreForPlayer = tempScoreForRulesCheck; // Apply the calculated score
                    pointsDeductedThisTurnForHistory = actualPointsScoredThisTurn; // Use the actual points scored for history

                    // NEW LOGIC: Check for 69 score at the end of the turn and prioritize it
                    if (finalScoreForPlayer === 69 && (gameMode === '301' || gameMode === '501')) {
                        const score69Phrase = score69Phrases[Math.floor(Math.random() * score69Phrases.length)];
                        turnMessage = `${currentPlayer} a fait ${pointsDeductedThisTurnForHistory} points. ${score69Phrase}`;
                        aiVoiceMessages = [turnMessage]; // Reset aiVoiceMessages and ONLY add the 69 phrase
                        console.log(`[DEBUG] 69 score detected for ${currentPlayer}. Message: ${turnMessage}`); // Debug log
                    } else {
                        // Determine general comment category
                        let commentCategory;
                        if (pointsDeductedThisTurnForHistory <= 40) commentCategory = 'low';
                        else if (pointsDeductedThisTurnForHistory <= 80) commentCategory = 'medium';
                        else if (pointsDeductedThisTurnForHistory <= 120) commentCategory = 'good';
                        else if (pointsDeductedThisTurnForHistory <= 179) commentCategory = 'high';
                        else if (pointsDeductedThisTurnForHistory === 180) commentCategory = '180';
                        else commentCategory = 'low'; // Fallback

                        const turnSummary = `${currentPlayer} a fait ${pointsDeductedThisTurnForHistory} points. ${getRandomComment(commentCategory)}`;
                        turnMessage = turnSummary; // Set display message
                        aiVoiceMessages.push(turnSummary); // Add to voice queue
                    }
                }
                // Update playerHasDoubledIn state for the player for the next turn
                playerHasDoubledIn[currentPlayer] = tempPlayerHasDoubledInForRulesCheck;
            }

            // Update the player's official score
            playerScores[currentPlayer] = finalScoreForPlayer;

            // Update history for this turn
            history[currentPlayer].push({
                darts: dartsForThisTurn.map(d => d.display).join(', '),
                scoreEntered: atcMode ? pointsDeductedThisTurnForHistory : pointsDeductedThisTurnForHistory, // For ATC, scoreEntered is number of darts advanced
                newTotal: playerScores[currentPlayer], // This is the actual new score/target after the turn
                message: turnMessage
            });

            // Reset current turn state for next player
            currentDartsThrown = [];
            selectedMultiplier = 1;
            showMessage(turnMessage); // Update visual message on screen

            // Speak all accumulated messages sequentially
            console.log("AI Voice Messages for this turn (final queue):", aiVoiceMessages); // Final debug log
            aiVoiceMessages.forEach(msg => speakMessage(msg));

            // Move to next player if game is not ended
            if (!gameEnded) {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length; // Advance to next player
                updateUI(); // Update UI to show next player immediately

                const nextPlayerName = players[currentPlayerIndex];
                const nextPlayerScore = playerScores[nextPlayerName];

                let msg = `C'est au tour de ${nextPlayerName}.`;
                if (!atcMode && nextPlayerScore <= 170 && nextPlayerScore > 1) { // Announce remaining score for 301/501
                    msg += ` Il vous reste ${nextPlayerScore} points.`;
                } else if (atcMode) { // Announce next target for ATC
                    msg += ` Votre cible est le numÃ©ro ${nextPlayerScore === 25 ? 'Bullseye' : nextPlayerScore}.`;
                }
                // Removed the general AI comment for each turn here.
                speakMessage(msg); // Add next turn announcement to speech queue
            } else {
                updateUI(); // Update UI immediately if game ended (winner screen)
            }
        }

        function handleMultiplierClick(multiplier) {
            if (currentDartsThrown.length >= 3) {
                showMessage('Vous avez dÃ©jÃ  lancÃ© 3 flÃ©chettes pour ce tour.');
                updateUI();
                return;
            }
            selectedMultiplier = multiplier;
            showMessage('');
            updateUI();
        }

        function handleNumberClick(event) {
            const num = parseInt(event.target.dataset.value, 10);
            const currentPlayer = players[currentPlayerIndex];

            if (winner || !gameStarted) {
                showMessage("Le jeu est terminÃ© ou n'a pas commencÃ©.");
                updateUI();
                return;
            }

            if (currentDartsThrown.length >= 3) {
                showMessage('Vous avez dÃ©jÃ  lancÃ© 3 flÃ©chettes pour ce tour.');
                updateUI();
                return;
            }

            // Specific validation for bullseye and triples
            if (num === 25 && selectedMultiplier === 3) {
                showMessage('Le Bullseye (25) ne peut pas Ãªtre un Triple. Veuillez choisir Double ou Simple.');
                updateUI();
                return;
            }
            if (num === 0 && selectedMultiplier !== 1) {
                showMessage('Un "miss" (0) ne peut pas Ãªtre un Double ou Triple.');
                updateUI();
                return;
            }

            const displayMultiplier = selectedMultiplier === 2 ? 'D' : selectedMultiplier === 3 ? 'T' : '';
            const dartScore = num * selectedMultiplier;

            const newDart = {
                value: num,
                multiplier: selectedMultiplier,
                score: dartScore,
                display: `${displayMultiplier}${num}`
            };

            // Get the score at the very beginning of the current turn for accurate simulation
            const scoreAtStartOfTurn = getScoreAtStartOfCurrentTurn(currentPlayer);
            
            // Simulate the score deduction for live display and early submission check
            let simulatedScoreForLiveDisplay = scoreAtStartOfTurn;
            let tempPlayerHasDoubledInForLiveCheck = playerHasDoubledIn[currentPlayer];
            let simulatedNextTargetForATC = scoreAtStartOfTurn; // For ATC live update

            let currentDartsPlusNew = [...currentDartsThrown, newDart]; // All darts for this turn including the new one

            for (const dart of currentDartsPlusNew) {
                if (atcMode) {
                    // ATC live update logic: Check if this dart hits the current simulated target with allowed multiplier
                    let hitCurrentTarget = false;
                    if (dart.value === simulatedNextTargetForATC) {
                        if (atcAllowedHitTypes.simple && dart.multiplier === 1) {
                            hitCurrentTarget = true;
                        } else if (atcAllowedHitTypes.double && dart.multiplier === 2) {
                            hitCurrentTarget = true;
                        } else if (atcAllowedHitTypes.triple && dart.multiplier === 3) {
                            hitCurrentTarget = true;
                        }
                    }
                    if (hitCurrentTarget) {
                        simulatedNextTargetForATC++;
                        if (simulatedNextTargetForATC > 20 && simulatedNextTargetForATC < 25) {
                            simulatedNextTargetForATC = 25;
                        } else if (simulatedNextTargetForATC > 25) {
                            // Game ends, but we are just simulating for live display, not ending game yet.
                            // The actual game ending will be handled in submitTurn.
                        }
                    }
                } else {
                    // X01 live update logic
                    let scoreToDeductInSimulation = dart.score;
                    if (doubleInActive && !tempPlayerHasDoubledInForLiveCheck) {
                        if (dart.multiplier === 2 && dart.value !== 0) {
                            tempPlayerHasDoubledInForLiveCheck = true;
                        } else {
                            scoreToDeductInSimulation = 0;
                        }
                    }
                    simulatedScoreForLiveDisplay -= scoreToDeductInSimulation;
                }
            }

            // Update playerScores for live display
            if (atcMode) {
                playerScores[currentPlayer] = simulatedNextTargetForATC;
            } else { // X01 modes
                playerScores[currentPlayer] = simulatedScoreForLiveDisplay;
            }

            // Add the dart to currentDartsThrown (this is the actual list of darts for the turn)
            currentDartsThrown.push(newDart);

            // Reset multiplier for the next dart input
            selectedMultiplier = 1;
            showMessage(''); // Clear message

            // Check for early submission if 3 darts are thrown or if a win/bust condition is met
            let shouldSubmitEarly = false;
            if (atcMode) {
                if (playerScores[currentPlayer] > 25) { // ATC game ends if target goes beyond 25
                    shouldSubmitEarly = true;
                }
            } else { // X01 modes
                if (playerScores[currentPlayer] < 0 || playerScores[currentPlayer] === 1) { // Bust due to score < 0 or === 1
                    shouldSubmitEarly = true;
                } else if (playerScores[currentPlayer] === 0) { // Potential win or bust due to non-double out
                    const lastAddedDart = newDart; // The most recently added dart
                    if (doubleOutActive) {
                        if (lastAddedDart.multiplier === 2 && lastAddedDart.value !== 0) { // Valid double out
                            shouldSubmitEarly = true;
                        } else {    
                            // Hit 0 but not with a double when Double Out is active -> THIS IS THE BUST CONDITION
                            // We need to force a bust here and revert the score immediately for display
                            playerScores[currentPlayer] = scoreAtStartOfTurn; // Revert score for display
                            showMessage(`${currentPlayer} a fait un "bust" ! Doit terminer avec un "Double Out". Score rÃ©tabli Ã  ${scoreAtStartOfTurn}.`);
                            if (scoreAtStartOfTurn > 70) {
                                speakMessage(kevinadePhrases[Math.floor(Math.random() * kevinadePhrases.length)]);
                            } else {
                                speakMessage(getRandomComment('bust'));
                            }
                            shouldSubmitEarly = true; // Submit turn immediately
                        }    
                    } else { // Straight out win (no double out rule)
                        shouldSubmitEarly = true;
                    }
                }
            }

            if (shouldSubmitEarly || currentDartsThrown.length === 3) {
                submitTurn(currentDartsThrown);
            } else {
                updateUI(); // Update UI to show new dart and live score
            }
        }

        function undoLastDart() {
            if (currentDartsThrown.length > 0) {
                if (!gameStarted && winner) {
                    showMessage("Le jeu est terminÃ©. Impossible d'annuler.");
                    updateUI();
                    return;
                }

                const removedDart = currentDartsThrown.pop();
                const currentPlayer = players[currentPlayerIndex];

                // Recalculate the live score after undoing the dart
                const scoreAtStartOfTurn = getScoreAtStartOfCurrentTurn(currentPlayer);
                
                let simulatedScoreAfterUndo = scoreAtStartOfTurn;
                let tempPlayerHasDoubledInAfterUndo = playerHasDoubledIn[currentPlayer];
                let simulatedNextTargetForATC = scoreAtStartOfTurn; // For ATC live update

                for (const dart of currentDartsThrown) { // Iterate through remaining darts
                    if (atcMode) {
                        // ATC live update logic
                        let hitCurrentTarget = false;
                        if (dart.value === simulatedNextTargetForATC) {
                            if (atcAllowedHitTypes.simple && dart.multiplier === 1) {
                                hitCurrentTarget = true;
                            } else if (atcAllowedHitTypes.double && dart.multiplier === 2) {
                                hitCurrentTarget = true;
                            } else if (atcAllowedHitTypes.triple && dart.multiplier === 3) {
                                hitCurrentTarget = true;
                            }
                        }
                        if (hitCurrentTarget) {
                            simulatedNextTargetForATC++;
                            if (simulatedNextTargetForATC > 20 && simulatedNextTargetForATC < 25) {
                                simulatedNextTargetForATC = 25;
                            } else if (simulatedNextTargetForATC > 25) {
                                // Game ends, but we are just simulating for live display.
                            }
                        }
                    } else {
                        // X01 live update logic
                        let scoreToDeductInSimulation = dart.score;
                        if (doubleInActive && !tempPlayerHasDoubledInAfterUndo) {
                            if (dart.multiplier === 2 && dart.value !== 0) {
                                tempPlayerHasDoubledInAfterUndo = true;
                            } else {
                                scoreToDeductInSimulation = 0;
                            }
                        }
                        simulatedScoreAfterUndo -= scoreToDeductInSimulation;
                    }
                }

                // Update playerScores for live display
                if (atcMode) {
                    playerScores[currentPlayer] = simulatedNextTargetForATC;
                } else { // X01 modes
                    playerScores[currentPlayer] = simulatedScoreAfterUndo;
                }

                selectedMultiplier = 1;
                showMessage('');
                updateUI();
            } else {
                showMessage('Aucune flÃ©chette Ã  annuler pour le tour.');
                updateUI();
            }
        }

        // --- Statistics Functions ---
        function showStatsPage() {
            statsSection.classList.add('active'); // Activate stats section
            updateUI(); // Hide other sections and show stats
            renderPlayerStats();
        }

        function renderPlayerStats() {
            playerStatsSummary.innerHTML = ''; // Clear previous stats

            players.forEach(player => {
                const playerStatDiv = document.createElement('div');
                playerStatDiv.className = 'bg-gray-900 p-4 rounded-lg border border-gray-600 shadow-md';

                let totalScoreSum = 0;
                let turnCount = 0;
                let totalDarts = 0;
                let hitSegments = {}; // { '20': { simple: 5, double: 2, triple: 1 }, '1': { ... } }

                // Calculate average score per turn (only for 301/501)
                if (!atcMode) {
                    history[player].forEach(turn => {
                        // Only count turns where points were deducted (not busts that revert score)
                        if (turn.scoreEntered > 0 || (turn.newTotal === 0 && turn.scoreEntered > 0)) { // Include winning turns
                            totalScoreSum += turn.scoreEntered;
                            turnCount++;
                        }
                    });
                }
                
                // Collect all darts for dartboard visualization
                allDartsThrown[player].forEach(dart => {
                    totalDarts++;
                    const segmentKey = dart.value.toString();
                    if (!hitSegments[segmentKey]) {
                        hitSegments[segmentKey] = { simple: 0, double: 0, triple: 0 };
                    }
                    if (dart.multiplier === 1) hitSegments[segmentKey].simple++;
                    else if (dart.multiplier === 2) hitSegments[segmentKey].double++;
                    else if (dart.multiplier === 3) hitSegments[segmentKey].triple++;
                });

                const averageScore = turnCount > 0 ? (totalScoreSum / turnCount).toFixed(2) : 'N/A';

                playerStatDiv.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-yellow-200">${player}</h3>
                    ${!atcMode ? `<p class="text-lg text-gray-300">Score moyen par tour: <span class="font-bold text-green-400">${averageScore}</span></p>` : ''}
                    <p class="text-lg text-gray-300">Total flÃ©chettes lancÃ©es: <span class="font-bold text-blue-400">${totalDarts}</span></p>
                    <h4 class="text-lg font-semibold mt-4 mb-2 text-purple-300">Zones touchÃ©es:</h4>
                    <canvas id="dartboardCanvas-${player}" width="200" height="200" class="bg-gray-800 rounded-md"></canvas>
                `;
                playerStatsSummary.appendChild(playerStatDiv);

                // Draw dartboard for each player
                drawDartboard(document.getElementById(`dartboardCanvas-${player}`), hitSegments);
            });
        }

        function drawDartboard(canvas, hitSegments) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = canvas.width / 2 - 10; // Max radius with some padding

            // Define dartboard ring radii (simplified for visualization)
            const bullseyeRadius = maxRadius * 0.08;
            const outerBullRadius = maxRadius * 0.16;
            const singleInnerRing = maxRadius * 0.5;
            const tripleRing = maxRadius * 0.55;
            const tripleOuterRing = maxRadius * 0.65;
            const doubleRing = maxRadius * 0.95;
            const doubleOuterRing = maxRadius * 1.0;

            // Segment values in dartboard order (clockwise from 20)
            const segmentOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

            // Function to get color based on hit count
            function getHitColor(count) {
                if (count === 0) return 'rgba(50, 50, 50, 0.2)'; // Very light, almost transparent
                if (count < 3) return 'rgba(255, 255, 0, 0.4)'; // Yellow, low hits
                if (count < 7) return 'rgba(255, 165, 0, 0.6)'; // Orange, medium hits
                if (count < 15) return 'rgba(255, 69, 0, 0.8)'; // Red-orange, high hits
                return 'rgba(255, 0, 0, 1)'; // Red, very high hits
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw segments and fill based on hits
            for (let i = 0; i < 20; i++) {
                const startAngle = (Math.PI / 10) * i - Math.PI / 20; // Adjust for segment 20 at top
                const endAngle = (Math.PI / 10) * (i + 1) - Math.PI / 20;
                const segmentValue = segmentOrder[i];

                // Draw Outer Single (between triple and double)
                ctx.beginPath();
                ctx.arc(centerX, centerY, tripleRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * singleInnerRing, centerY + Math.sin(endAngle) * singleInnerRing);
                ctx.arc(centerX, centerY, singleInnerRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].simple : 0); // Color based on simple hits
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Triple Ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, tripleOuterRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * tripleRing, centerY + Math.sin(endAngle) * tripleRing);
                ctx.arc(centerX, centerY, tripleRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].triple : 0); // Color based on triple hits
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Double Ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, doubleOuterRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * doubleRing, centerY + Math.sin(endAngle) * doubleRing);
                ctx.arc(centerX, centerY, doubleRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].double : 0); // Color based on double hits
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw Outer Bull (25)
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerBullRadius, 0, Math.PI * 2);
            ctx.fillStyle = getHitColor(hitSegments['25'] ? hitSegments['25'].simple : 0);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw Bullseye (Inner Bull) (25)
            ctx.beginPath();
            ctx.arc(centerX, centerY, bullseyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = getHitColor(hitSegments['25'] ? hitSegments['25'].double : 0); // Assuming inner bull is D-Bull
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Add labels (optional, can clutter small canvas)
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // For a small canvas, labels might be too much.
            // If needed, calculate positions for 20, 15, etc.
        }


        function hideStatsPage() {
            statsSection.classList.remove('active');
            updateUI(); // Show appropriate sections
        }

        // Function to update rule options visibility based on game mode
        function updateRuleOptionsVisibility() {
            const selectedMode = gameModeSelect.value;
            if (selectedMode === 'atc') { // Check for the generic 'atc' mode
                x01RulesDiv.classList.add('hidden');
                atcRulesDiv.classList.remove('hidden');
                // Set default checked state for ATC options to all checked
                atcAllowSimpleCheckbox.checked = true;
                atcAllowDoubleCheckbox.checked = true;
                atcAllowTripleCheckbox.checked = true;
            } else { // For 301/501 modes
                x01RulesDiv.classList.remove('hidden');
                atcRulesDiv.classList.add('hidden');
            }
        }


        // Event Listeners for new buttons
        showStatsBtn.addEventListener('click', showStatsPage);
        backToMainFromStatsBtn.addEventListener('click', hideStatsPage);

        // Event Listeners for existing buttons
        addPlayerBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            addPlayer();
        });
        startGameBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            startGame();
        });
        resetGameBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            resetGame();
        });
        newGameWinnerBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            resetGame();
        });
        undoLastDartBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            undoLastDart();
        });

        multiplierSimpleBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            handleMultiplierClick(1);
        });
        multiplierDoubleBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            handleMultiplierClick(2);
        });
        multiplierTripleBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            handleMultiplierClick(3);
        });

        // Event listener for number keypad buttons (delegation)
        numberKeypad.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON' && event.target.dataset.value !== undefined) {
                createRipple(event); // Add ripple effect
                handleNumberClick(event);
            }
        });

        // Event listener for removing players from the list
        playersList.addEventListener('click', (event) => {
            if (event.target.closest('button') && event.target.closest('button').dataset.player) {
                createRipple(event); // Add ripple effect
                const playerToRemove = event.target.closest('button').dataset.player;
                removePlayer(playerToRemove);
            }
        });

        // New event listener for game mode selection change
        gameModeSelect.addEventListener('change', updateRuleOptionsVisibility);

        // Initial render on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Script loaded and DOMContentLoaded."); // Debug log
            renderNumberKeypad(); // Render number buttons once
            updateRuleOptionsVisibility(); // Call initially to set correct visibility
            updateUI(); // Initial UI update

            // Explicitly call getVoices() once to potentially kickstart voice loading
            // on some browsers, though onvoiceschanged should handle it.
            if (speechSynth) {
                speechSynth.getVoices();
            }
        });

    </script>
</body>
</html>
