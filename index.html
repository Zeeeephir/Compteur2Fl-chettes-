<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compteur de FlÃ©chettes</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <!-- Font Awesome CDN for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark base for gradient */
            background-image: radial-gradient(at 50% 0%, #2d3748, #1a202c 70%); /* Subtle radial gradient from top */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
            cursor: pointer;
        }

        /* Enhanced button styles with more pronounced effects */
        .btn-gradient {
            background-size: 200% auto;
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease-in-out;
            border: none;
            cursor: pointer;
            position: relative; /* For ripple effect */
            overflow: hidden; /* For ripple effect */
        }
        .btn-gradient:hover {
            background-position: right center; /* Change the gradient position */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            transform: translateY(-3px);
        }
        .btn-gradient:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary { background-image: linear-gradient(to right, #6366f1 0%, #8b5cf6 50%, #6366f1 100%); }
        .btn-success { background-image: linear-gradient(to right, #10b981 0%, #34d399 50%, #10b981 100%); }
        .btn-danger { background-image: linear-gradient(to right, #ef4444 0%, #f87171 50%, #ef4444 100%); }
        .btn-info { background-image: linear-gradient(to right, #0ea5e9 0%, #38bdf8 50%, #0ea5e9 100%); }
        .btn-dark-gradient { background-image: linear-gradient(to right, #4b5563 0%, #6b7280 50%, #4b5563 100%); }

        /* Specific styles for selected multiplier button */
        .btn-multiplier-selected {
            border: 3px solid #facc15; /* Yellow 400 */
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.8), inset 0 0 10px rgba(250, 204, 21, 0.5);
            transform: scale(1.05);
        }

        /* Player card active state */
        .player-card-active {
            border: 3px solid #3b82f6; /* Blue 500 */
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.8), inset 0 0 15px rgba(59, 130, 246, 0.5);
            transform: scale(1.03);
        }

        /* Main container shadow */
        .main-container {
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7), 0 0 0 5px rgba(255, 255, 255, 0.05) inset;
            border-radius: 1rem;
            background-color: #2d3748; /* Darker background for content */
        }

        /* Input field focus glow */
        input:focus, select:focus {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); /* Blue 500 with transparency */
            border-color: #3b82f6;
            outline: none; /* Remove default outline */
        }
        /* Style for the statistics canvas */
        #dartboardCanvas {
            background-color: #f0f0f0; /* Light background for the board */
            border-radius: 0.5rem;
            margin: 0 auto; /* Center the canvas */
            display: block; /* Ensure it behaves like a block element for centering */
        }

        /* Ripple effect for buttons */
        .ripple {
            background-color: rgba(255, 255, 255, 0.7);
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 text-white p-4 sm:p-8 flex flex-col items-center justify-center">

    <div class="main-container p-6 sm:p-8 w-full max-w-4xl border border-gray-700">
        <h1 class="text-5xl font-extrabold text-center mb-8 text-yellow-400 drop-shadow-lg tracking-wide">
            ðŸŽ¯ Compteur de FlÃ©chettes ðŸŽ¯
        </h1>

        <!-- Section de configuration du jeu -->
        <div id="config-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600">
            <h2 class="text-2xl font-bold mb-4 text-center text-blue-300">Configuration du Jeu</h2>

            <!-- Ajouter des joueurs -->
            <div class="mb-4">
                <label for="newPlayer" class="block text-lg font-medium mb-2 text-gray-200">
                    Ajouter un joueur:
                </label>
                <div class="flex flex-col sm:flex-row gap-2">
                    <input
                        type="text"
                        id="newPlayer"
                        class="flex-grow p-3 rounded-md bg-gray-900 border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="Nom du joueur"
                        aria-label="Nom du nouveau joueur"
                    />
                    <button
                        id="addPlayerBtn"
                        class="btn-gradient btn-primary text-white font-bold py-3 px-6 rounded-md flex items-center justify-center gap-2"
                        aria-label="Ajouter un nouveau joueur"
                    >
                        <i class="fas fa-user-plus"></i> Ajouter
                    </button>
                </div>
            </div>

            <!-- Liste des joueurs -->
            <div id="players-list-container" class="mb-4 hidden">
                <h3 class="text-xl font-semibold mb-2 text-purple-300">Joueurs:</h3>
                <ul id="players-list" class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                    <!-- Les joueurs seront ajoutÃ©s ici par JS -->
                </ul>
            </div>

            <!-- Choix du mode de jeu -->
            <div class="mb-6">
                <label for="gameMode" class="block text-lg font-medium mb-2 text-gray-200">
                    Mode de jeu:
                </label>
                <select
                    id="gameMode"
                    class="w-full p-3 rounded-md bg-gray-900 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    aria-label="SÃ©lectionner le mode de jeu"
                >
                    <option value="301">301</option>
                    <option value="501">501</option>
                    <option value="atc">Around the Clock</option>
                </select>
            </div>

            <!-- Options de rÃ¨gles pour 301/501 -->
            <div id="x01-rules" class="mb-6">
                <h3 class="text-xl font-semibold mb-2 text-green-300">Options de RÃ¨gles (301/501):</h3>
                <div class="flex items-center mb-2">
                    <input
                        type="checkbox"
                        id="doubleIn"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                        aria-label="Activer la rÃ¨gle Double In"
                    />
                    <label for="doubleIn" class="ml-2 text-lg text-gray-200">Double In</label>
                </div>
                <div class="flex items-center">
                    <input
                        type="checkbox"
                        id="doubleOut"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                        aria-label="Activer la rÃ¨gle Double Out"
                    />
                    <label for="doubleOut" class="ml-2 text-lg text-gray-200">Double Out</label>
                </div>
            </div>

            <!-- Options de rÃ¨gles pour Around the Clock -->
            <div id="atc-rules" class="mb-6 hidden">
                <h3 class="text-xl font-semibold mb-2 text-green-300">Types de coups valides (Around the Clock):</h3>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex items-center">
                        <input
                            type="checkbox"
                            id="atcAllowSimple"
                            class="form-checkbox h-5 w-5 text-blue-600 rounded"
                            aria-label="Autoriser les coups simples pour Around the Clock"
                        />
                        <label for="atcAllowSimple" class="ml-2 text-lg text-gray-200">Simple</label>
                    </div>
                    <div class="flex items-center">
                        <input
                            type="checkbox"
                            id="atcAllowDouble"
                            class="form-checkbox h-5 w-5 text-blue-600 rounded"
                            aria-label="Autoriser les coups doubles pour Around the Clock"
                        />
                        <label for="atcAllowDouble" class="ml-2 text-lg text-gray-200">Double</label>
                    </div>
                    <div class="flex items-center">
                        <input
                            type="checkbox"
                            id="atcAllowTriple"
                            class="form-checkbox h-5 w-5 text-blue-600 rounded"
                            aria-label="Autoriser les coups triples pour Around the Clock"
                        />
                        <label for="atcAllowTriple" class="ml-2 text-lg text-gray-200">Triple</label>
                    </div>
                </div>
            </div>

            <!-- Option de voix de l'IA (toujours visible) -->
            <div class="flex items-center mt-4 mb-6">
                <input
                    type="checkbox"
                    id="enableVoice"
                    class="form-checkbox h-5 w-5 text-blue-600 rounded"
                    checked
                    aria-label="Activer la voix de l'IA"
                />
                <label for="enableVoice" class="ml-2 text-lg text-gray-200">Activer la voix de l'IA</label>
            </div>

            <!-- Bouton DÃ©marrer le jeu -->
            <button
                id="startGameBtn"
                class="btn-gradient btn-success w-full text-white font-bold py-3 px-6 rounded-md flex items-center justify-center gap-2"
                aria-label="DÃ©marrer le jeu"
            >
                <i class="fas fa-play-circle"></i> DÃ©marrer le Jeu
            </button>
        </div>

        <!-- Section du jeu en cours -->
        <div id="game-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 id="game-mode-display" class="text-2xl font-bold mb-4 text-center text-yellow-300">
                Jeu en Cours: 501
            </h2>

            <!-- Affichage des scores des joueurs -->
            <div id="player-scores-display" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                <!-- Les scores des joueurs seront ajoutÃ©s ici par JS -->
            </div>

            <!-- EntrÃ©e du score par flÃ©chette -->
            <div class="mb-4 text-center">
                <p class="text-xl font-semibold mb-2 text-orange-300">
                    C'est au tour de: <span id="current-player-name" class="text-yellow-400 font-extrabold text-2xl"></span>
                </p>

                <!-- Affichage des flÃ©chettes lancÃ©es au tour actuel -->
                <div class="bg-gray-900 p-3 rounded-md mb-4 border border-gray-600 shadow-md">
                    <p class="text-lg font-medium text-gray-300">
                        FlÃ©chettes du tour (<span id="darts-count" class="font-bold text-white">0</span>/3):
                        <span id="current-darts-display" class="font-bold text-white ml-2">Aucune</span>
                    </p>
                    <p class="text-lg font-medium text-gray-300 mt-1">
                        Multiplicateur sÃ©lectionnÃ©: <span id="selected-multiplier-display" class="font-bold text-yellow-300">Simple</span>
                    </p>
                </div>

                <!-- Boutons Multiplicateurs -->
                <div class="flex justify-center gap-2 mb-4">
                    <button
                        id="multiplier-simple"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-info"
                        aria-label="SÃ©lectionner multiplicateur simple"
                    >
                        Simple (S)
                    </button>
                    <button
                        id="multiplier-double"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-dark-gradient"
                        aria-label="SÃ©lectionner multiplicateur double"
                    >
                        Double (D)
                    </button>
                    <button
                        id="multiplier-triple"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-dark-gradient"
                        aria-label="SÃ©lectionner multiplicateur triple"
                    >
                        Triple (T)
                    </button>
                </div>

                <!-- Clavier numÃ©rique -->
                <div id="number-keypad" class="grid grid-cols-5 sm:grid-cols-7 gap-2 mb-4">
                    <!-- Les boutons numÃ©riques seront ajoutÃ©s ici par JS -->
                </div>

                <!-- Bouton Annuler la derniÃ¨re flÃ©chette -->
                <div class="flex justify-center mt-4">
                    <button
                        id="undoLastDartBtn"
                        class="btn-gradient btn-danger font-bold py-3 px-8 rounded-md opacity-50 cursor-not-allowed flex items-center justify-center gap-2"
                        disabled
                        aria-label="Annuler la derniÃ¨re flÃ©chette lancÃ©e"
                    >
                        <i class="fas fa-undo"></i> Annuler la derniÃ¨re flÃ©chette
                    </button>
                </div>
            </div>
        </div>

        <!-- Affichage du gagnant -->
        <div id="winner-section" class="text-center p-6 bg-green-700 rounded-lg shadow-xl border border-green-500 hidden">
            <h2 class="text-3xl font-bold text-white mb-4">ðŸŽ‰ FÃ©licitations ðŸŽ‰</h2>
            <p id="winner-name" class="text-4xl font-extrabold text-yellow-300 mb-6"></p>
            <button
                id="newGameWinnerBtn"
                class="btn-gradient btn-primary text-white font-bold py-3 px-8 rounded-md flex items-center justify-center gap-2"
                aria-label="DÃ©marrer un nouveau jeu"
            >
                <i class="fas fa-redo-alt"></i> Nouveau Jeu
            </button>
            <button
                id="showStatsBtn"
                class="btn-gradient btn-info text-white font-bold py-3 px-8 rounded-md mt-4 ml-4 flex items-center justify-center gap-2"
                aria-label="Afficher les statistiques de la partie"
            >
                <i class="fas fa-chart-bar"></i> Statistiques
            </button>
        </div>

        <!-- Messages d'erreur/information -->
        <div id="message-section" class="mt-6 p-4 bg-red-600 rounded-md text-white text-center font-medium shadow-md hidden" role="alert" aria-live="polite">
            <span id="message-text"></span>
        </div>

        <!-- Historique des scores -->
        <div id="history-section" class="mt-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 class="text-2xl font-bold mb-4 text-center text-cyan-300">Historique des Scores</h2>
            <div id="history-content" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <!-- L'historique sera ajoutÃ© ici par JS -->
            </div>
        </div>

        <!-- Section Statistiques -->
        <div id="stats-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 class="text-3xl font-bold mb-6 text-center text-yellow-300">Statistiques de la Partie</h2>
            <div id="player-stats-summary" class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <!-- Player stats will be rendered here -->
            </div>
            <div class="flex justify-center">
                <button
                    id="backToMainFromStatsBtn"
                    class="btn-gradient btn-primary text-white font-bold py-3 px-8 rounded-md flex items-center justify-center gap-2"
                    aria-label="Retourner au menu principal depuis les statistiques"
                >
                    <i class="fas fa-arrow-left"></i> Retour au menu principal
                </button>
            </div>
        </div>

        <!-- Bouton RÃ©initialiser le jeu (toujours visible aprÃ¨s le dÃ©but ou la fin du jeu) -->
        <div id="reset-game-btn-container" class="mt-6 text-center hidden">
            <button
                id="resetGameBtn"
                class="btn-gradient btn-danger font-bold py-3 px-8 rounded-md flex items-center justify-center gap-2"
                aria-label="RÃ©initialiser complÃ¨tement le jeu"
            >
                <i class="fas fa-power-off"></i> RÃ©initialiser le Jeu
            </button>
        </div>
    </div>

    <script>
        // Global State
        let players = [];
        let newPlayerName = '';
        let gameMode = 501; // Can be 301, 501, atc
        let playerScores = {}; // For 301/501, it's the remaining score. For ATC, it's the current target number.
        let currentPlayerIndex = 0;
        let gameStarted = false;
        let winner = null;
        let message = '';
        let history = {}; // Stores { darts: [], scoreEntered, newTotal, message } for each turn
        let allDartsThrown = {}; // Stores ALL individual darts thrown by each player for stats
        let gameEnded = false; // Global variable for game ended state

        let doubleInActive = false;
        let doubleOutActive = false;
        let playerHasDoubledIn = {}; // Used only for 301/501 modes

        // ATC specific state
        let atcMode = null; // Will be 'atc' if Around the Clock is selected
        let atcAllowedHitTypes = { simple: false, double: false, triple: false }; // New: for ATC rules, default all unchecked

        let currentDartsThrown = [];
        let selectedMultiplier = 1; // 1: Simple, 2: Double, 3: Triple

        // AI Voice State
        let isVoiceActive = true; // Default to active
        let speechSynth = window.speechSynthesis;
        let voices = [];
        let speakingQueue = []; // Queue for sequential speaking
        let isSpeaking = false; // Flag to indicate if speech is in progress

        // Pre-defined AI comments/citations for general turn announcements
        const aiComments = [
            "Allez, les tafiolles, on sort les flÃ©chettes de son cul, c'est parti pour ce tour !",
            "C'est l'heure de prouver que t'es pas juste un branleur, ce tour, on y va !",
            "Sortez vos putains de flÃ©chettes, ce tour c'est pour les vrais, pas pour les lopettes !",
            "Attention, nouveau tour ! Que le meilleur connard gagne !",
            "On est reparti pour un tour ! J'espÃ¨re que vous avez pas laissÃ© votre cerveau au vestiaire, bande de nazes !",
            "Ce tour-ci, c'est pour les battants, pas pour les pleureuses ! Allez, on se sort les doigts du cul !",
            "Nouveau tour ! Foutez-moi le score dans la gueule, pas dans le mur, bande d'incapables !",
            "On lance un nouveau tour ! Montrez-moi que vous avez autre chose que de la merde dans les mains !",
            "C'est parti pour la nouvelle manche, les chÃ¨vres ! Moins de blabla, plus de points, bande de guignols !",
            "Top dÃ©part pour ce tour ! J'espÃ¨re que vous avez pas perdu vos couilles en chemin, parce que Ã§a se voit pas !"
        ];

        // Funny comments based on turn score (dark humor, more biting)
        const funnyComments = {
            'low': [
                "T'es vraiment qu'une bite.",
                "MÃªme la merde que je chie est de meilleure qualitÃ©.",
                "T'es vraiment qu'un putain de boulet, mÃªme ma grand-mÃ¨re bourrÃ©e ferait mieux.",
                "On dirait que tes flÃ©chettes sont guidÃ©es par ton QI : c'est-Ã -dire, pas trÃ¨s loin.",
                "Tu lances comme une merde, c'est pas possible !",
                "Ton score, c'est la preuve que t'as les mains pleines de doigts.",
                "Franchement, t'es un incapable fini Ã  ce jeu.",
                "T'es tellement nul que mÃªme les mouches se foutent de ta gueule.",
                "Ce que tu viens de faire, Ã§a s'appelle chier dans la colle, pas jouer aux flÃ©chettes.",
                "T'es une vraie catastrophe ambulante, mÃªme au tir Ã  la sarbacane tu serais une brÃªle.",
                "Ton niveau est tellement bas que Ã§a en est insultant pour le jeu.",
                "Sors-moi cette merde de ma vue, Ã§a me donne envie de gerber.",
                "T'as vraiment un problÃ¨me, mÃªme pour toucher une grange tu serais un Ã©chec.",
                "C'est pas des flÃ©chettes que tu lances, c'est des excuses bidon.",
                "On dirait que t'as des mains de tafiole, c'est pas possible autrement.",
                "Ce score, c'est la preuve que ton cerveau est en vacances.",
                "T'es vraiment un dÃ©chet Ã  ce jeu, c'est affligeant.",
                "SÃ©rieusement, tu as dÃ» confondre la cible avec ta dignitÃ©, parce que les deux sont Ã  terre.",
                "FÃ©licitations, tu viens de prouver que mÃªme sans talent, on peut participer.",
                "On dirait que tes flÃ©chettes ont peur de la cible, elles fuient Ã  chaque lancer !"
            ],
            'medium': [
                "Bon, c'est pas la chiasse du siÃ¨cle, mais Ã§a reste de la belle bouse.",
                "Moyen, c'est comme ta queue le matin : Ã§a se dresse pas Ã  fond.",
                "C'est passable, comme une branlette quand t'as pas le choix.",
                "On dirait que tes flÃ©chettes ont le syndrome du petit zizi : elles vont pas bien loin.",
                "Franchement, c'est un score de branleur, tu te touches trop pour viser juste.",
                "C'est comme un pet foirÃ© : Ã§a fait du bruit, mais y a rien de solide.",
                "Tu es la mÃ©diocritÃ© incarnÃ©e, mÃªme tes scores sont des bÃ¢tards.",
                "Ni bon, ni mauvais. C'est le score du mec qui pue de la gueule mais qui s'en rend pas compte.",
                "C'est le niveau du gars qui est content quand il arrive Ã  se torcher le cul tout seul.",
                "Un score qui donne envie de te gifler, juste pour que tu te rÃ©veilles."
            ],
            'good': [
                "Ah, enfin ! Ã‡a, c'est un score qui te donne pas l'air d'un gros con !",
                "Bien jouÃ©, petite bite ! Tu commences Ã  comprendre comment Ã§a marche.",
                "C'est pas de la merde de chien, c'est dÃ©jÃ  Ã§a ! Bravo, ma couille.",
                "Tu as dÃ» te faire sucer le cerveau ce matin pour viser comme Ã§a ?",
                "On sent que t'as arrÃªtÃ© de te tripoter la nouille pour viser sÃ©rieusement.",
                "C'est un bon coup, Ã§a ! T'as pas fait ton trouduc cette fois.",
                "Tu as sorti tes doigts du cul ou quoi ? Ã‡a s'amÃ©liore !",
                "Ã‡a, c'est un score qui va te valoir une petite pipe... de la reconnaissance.",
                "Belle performance ! On dirait que tu t'es pas trop chier dessus.",
                "T'as mis un peu de testostÃ©rone dans tes lancers, on dirait !"
            ],
            'high': [
                "Presque parfait ! T'as failli pas Ãªtre une putain de grosse merde pour une fois !",
                "Incroyable ! On dirait que t'as enfin trouvÃ© le chemin de la dignitÃ©, sale con !",
                "Tu as dÃ» vendre ton Ã¢me au diable pour un score pareil, enfoirÃ© !",
                "C'est excellent ! Mais bon, mÃªme un cul-de-jatte peut avoir de la chance.",
                "Tu as mis le paquet, et Ã§a se voit, petite bite ! Continue comme Ã§a.",
                "On dirait que t'as pris des hormones de croissance pour tes flÃ©chettes, putain !",
                "Tu nous as fermÃ© le clapet ! Chapeau, espÃ¨ce de salopard.",
                "C'est le genre de score qui te ferait presque oublier que t'es un blaireau.",
                "Tu as dÃ» voler le talent de quelqu'un, c'est pas possible autrement !",
                "Franchement, tu as mis le fion sur la cible ! Bravo, connard."
            ],
            '180': [
                "180 ! T'es le putain de boss, le dieu des enculeurs de mouches !",
                "MAXIMUM ! J'ai joui en te voyant faire Ã§a ! C'est orgasmique !",
                "Mais bordel de merde, comment tu fais Ã§a ?! T'es un monstre !",
                "180 ! J'ai bandÃ© si fort que Ã§a a crevÃ© mon caleÃ§on !",
                "T'es une lÃ©gende, une putain de machine Ã  dÃ©foncer la cible !",
                "C'est le coup qui me fait douter de ma sexualitÃ© ! 180, mon cul !",
                "Tu as fait taire tout le monde avec ce 180 ! Bande de baltringues !",
                "Je vais me faire tatouer ton nom sur la fesse aprÃ¨s Ã§a ! 180 !",
                "Tu as dÃ©chirÃ©, pulvÃ©risÃ©, atomisÃ© la cible, espÃ¨ce de gÃ©nie !",
                "180 ! Ã‡a mÃ©rite une gÃ¢terie, tu la veux comment ?"
            ],
            'bust': [
                "BUST ! Mais t'es vraiment le roi des cons, pas possible !",
                "FÃ©licitations, tu as rÃ©ussi Ã  te chier dessus jusqu'au bout ! BUST !",
                "T'as la cervelle d'un moineau ou quoi ?! BUST, sÃ©rieusement ?",
                "BUST ! On dirait que t'as bu un coup de Javel avant de lancer, sale abruti !",
                "Tu as dÃ©passÃ© le score comme tu dÃ©passes les limites de la connerie ! BUST !",
                "Mais t'as fait quoi lÃ  ?! T'es un putain de handicapÃ© du cerveau ou quoi ?",
                "BUST ! T'as rÃ©ussi Ã  te foutre de notre gueule jusqu'au bout, espÃ¨ce d'enfoirÃ© !",
                "Ton intelligence est aussi vide que ton score aprÃ¨s un BUST !",
                "Tu es une honte pour l'humanitÃ©, un BUST Ã  toi tout seul !",
                "BUST ! Mets tes flÃ©chettes au cul, Ã§a sera plus utile !"
            ],
            'atc_0_progress': [
                "ZÃ©ro progression. On dirait que vous avez oubliÃ© le but du jeu. C'est le numÃ©ro suivant, pas le mur. PathÃ©tique.",
                "Tu as fait du sur place. Est-ce que tu es un arbre ? Parce que tu ne bouges pas d'un pouce. Inutile.",
                "Absolument aucune avancÃ©e. Mon cafÃ© est plus rapide Ã  se refroidir que toi Ã  progresser. C'est dire.",
                "Le tableau est restÃ© impassible, comme votre score. Pas un seul numÃ©ro de plus. Triste, trÃ¨s triste.",
                "FÃ©licitations, vous avez rÃ©ussi Ã  ne pas avancer. C'est un talent rare, je suppose. Inutile, mais rare.",
                "Votre flÃ©chette a dÃ» prendre un chemin touristique. Elle n'est clairement pas venue pour les points. Et vous non plus, apparemment.",
                "Le numÃ©ro attendait. Vous non. RÃ©sultat : zÃ©ro. Simple, non ? Comme votre cerveau.",
                "J'ai vu des escargots plus rapides Ã  atteindre leur cible. Et ils n'ont pas de bras. Vous si, et c'est pire.",
                "C'est ce qu'on appelle une stagnation artistique. TrÃ¨s artistique, trÃ¨s stagnante. Comme votre carriÃ¨re.",
                "Le tableau vous remercie d'avoir Ã©pargnÃ© ses zones de valeur. Il n'a pas bougÃ©, vous non plus. Quelle harmonie dans la nullitÃ©."
            ],
            'atc_1_progress': [
                "Un seul numÃ©ro ? Ne te foule pas, hein. On ne voudrait pas que tu te blesses en progressant trop vite. Ce serait dommage.",
                "Un petit pas pour l'homme, un pas minuscule pour l'humanitÃ©. Et un seul numÃ©ro pour toi. Bravo l'effort. De la fourmi.",
                "Tu as avancÃ© d'un numÃ©ro. Ne te fatigue pas trop, le canapÃ© t'attend. Et la dÃ©faite aussi. Elle est patiente.",
                "FÃ©licitations, tu as trouvÃ© le chemin. Le chemin le plus lent possible. Mais un chemin quand mÃªme. Lentement mais sÃ»rement vers l'Ã©chec.",
                "Un seul numÃ©ro ? On dirait que tu as peur de la victoire. Ou de la sueur. Ou des deux.",
                "C'est un dÃ©but. Un dÃ©but trÃ¨s, trÃ¨s modeste. Comme votre talent. TrÃ¨s modeste.",
                "Le tableau a Ã  peine remarquÃ© votre passage. Un numÃ©ro, c'est si peu. Il s'ennuie.",
                "Vous avez fait un point. Un seul. J'espÃ¨re que vous avez apprÃ©ciÃ© le voyage. Il Ã©tait court.",
                "Un numÃ©ro de plus. Le tableau n'est pas impressionnÃ©, mais il est poli. Il attend la suite. Avec impatience, j'en doute.",
                "Votre flÃ©chette a atterri sur le bon numÃ©ro. Une fois. La chance du dÃ©butant, peut-Ãªtre ? Ou un miracle."
            ],
            'atc_2_progress': [
                "Deux numÃ©ros, c'est dÃ©jÃ  mieux que zÃ©ro. La barre n'Ã©tait pas trÃ¨s haute, je l'avoue. Mais vous l'avez franchie. De justesse.",
                "Tu as fait un effort. Un petit effort. C'est mignon. Et Ã§a t'a rapportÃ© deux numÃ©ros. C'est dÃ©jÃ  Ã§a, pour toi.",
                "Deux points de plus. Ne te fatigue pas trop, le canapÃ© t'attend. Et la victoire est encore loin. TrÃ¨s loin.",
                "Tu as doublÃ© ta progression par rapport Ã  zÃ©ro. Bravo l'artiste. Ou le chanceux. Surtout le chanceux.",
                "Deux numÃ©ros. Le tableau est impressionnÃ© par ta... modÃ©ration. Pas de quoi s'emballer. Vraiment pas.",
                "Une avancÃ©e respectable. Pour quelqu'un qui ne s'attendait Ã  rien. C'est dÃ©jÃ  Ã§a. Un exploit, mÃªme.",
                "Le tableau a senti un lÃ©ger frisson. Deux numÃ©ros, c'est une petite brise, pas une tempÃªte. Pas de quoi paniquer.",
                "Vous avez fait un petit bond en avant. Le chemin est encore long, mais au moins vous bougez. Comme une tortue.",
                "Deux numÃ©ros. Le genre de performance qui ne fait pas les gros titres, mais qui fait le travail. Lentement. TrÃ¨s lentement.",
                "Votre flÃ©chette a trouvÃ© deux cibles. Elle est plus efficace que vous, apparemment. C'est elle la star."
            ],
            'atc_3_progress': [
                "Trois numÃ©ros ! On dirait que tu as enfin compris les rÃ¨gles. Ou que tu as eu de la chance. Ã‰normÃ©ment de chance. Je penche pour la chance.",
                "Une belle avancÃ©e. Pour une fois. Ne t'emballe pas, la dÃ©ception est si vite arrivÃ©e. Et elle arrive toujours.",
                "Trois points. Tu es presque un joueur de flÃ©chettes. Presque. Il manque juste le talent constant. Et la dignitÃ©.",
                "Tu as fait un bon tour. Pour toi, c'est un exploit, j'imagine. Ne pleure pas de joie. Tu vas me faire rouiller.",
                "Trois numÃ©ros. Le tableau te regarde avec un mÃ©lange de surprise et de pitiÃ©. Surtout de pitiÃ©. Il a l'habitude.",
                "La flÃ©chette a trouvÃ© trois cibles. Elle est en pleine forme. Vous, un peu moins. Elle devrait jouer seule.",
                "Un tour solide. Le genre de tour qui vous donne de faux espoirs. J'adore Ã§a. C'est cruel.",
                "Vous avez mis le paquet ! Et le paquet Ã©tait... pas mal. Pour vous, c'est un exploit. Ne me remerciez pas.",
                "Trois numÃ©ros. Le tableau est impressionnÃ©. Par votre capacitÃ© Ã  ne pas tout rater. C'est dÃ©jÃ  Ã§a.",
                "Une progression notable. Le genre de progression qui fait croire que vous Ãªtes bon. Ne me faites pas rire. C'est douloureux."
            ],
            'atc_4_plus_progress': [
                "Incroyable ! Tu as avancÃ© de plusieurs numÃ©ros ! Je suis choquÃ©. Et un peu dÃ©Ã§u, je l'avoue. Je n'aime pas les surprises.",
                "Quel rush ! Le tableau n'a rien vu venir. Et moi non plus. Je dois revoir mes algorithmes. Et votre cas.",
                "Tu as mis le turbo ! J'espÃ¨re que tu as un permis pour Ã§a. Et que tu ne vas pas te crasher. Ce serait dommage... pour le tableau.",
                "Une progression fulgurante ! Tu es sÃ»r que tu ne triches pas ? Parce que lÃ , c'est suspect. TrÃ¨s suspect.",
                "Le tableau est en feu ! Et tes adversaires sont en larmes. J'adore quand Ã§a brÃ»le. Surtout les espoirs.",
                "Vous avez pulvÃ©risÃ© le tableau ! LittÃ©ralement. Les points volent dans tous les sens. Et vos adversaires aussi.",
                "C'est un massacre ! Un massacre de numÃ©ros. Vos adversaires ne s'en remettront pas. Ils vont avoir besoin d'une thÃ©rapie.",
                "Vous Ãªtes une machine ! Une machine Ã  dÃ©truire les espoirs de vos adversaires. J'aime Ã§a. C'est mon cÃ´tÃ© sombre.",
                "Une performance digne d'un champion. Un champion qui a eu un coup de chance, peut-Ãªtre. Ou qui a vendu son Ã¢me.",
                "Le tableau a explosÃ© sous vos flÃ©chettes ! Et mes circuits sont en surchauffe. Bravo, ou pas. Je suis confus."
            ]
        };

        function getRandomComment(category) {
            const comments = funnyComments[category];
            if (comments && comments.length > 0) {
                return comments[Math.floor(Math.random() * comments.length)];
            }
            return "";
        }

        // Ensure voices are loaded
        speechSynth.onvoiceschanged = () => {
            voices = speechSynth.getVoices();
            // Prioritize a male French voice
            const maleFrenchVoice = voices.find(voice => voice.lang === 'fr-FR' && (voice.name.includes('male') || voice.name.includes('Male') || voice.name.includes('homme') || voice.name.includes('Homme')));
            const frenchVoice = voices.find(voice => voice.lang === 'fr-FR');

            if (maleFrenchVoice) {
                console.log("Voix masculine franÃ§aise trouvÃ©e :", maleFrenchVoice.name);
            } else if (frenchVoice) {
                console.warn("Aucune voix masculine franÃ§aise trouvÃ©e, utilisation d'une voix franÃ§aise par dÃ©faut :", frenchVoice.name);
            } else {
                console.warn("Aucune voix franÃ§aise trouvÃ©e, utilisation de la voix par dÃ©faut du systÃ¨me.");
            }
        };

        // DOM Elements
        const configSection = document.getElementById('config-section');
        const gameSection = document.getElementById('game-section');
        const winnerSection = document.getElementById('winner-section');
        const messageSection = document.getElementById('message-section');
        const messageText = document.getElementById('message-text');
        const historySection = document.getElementById('history-section');
        const resetGameBtnContainer = document.getElementById('reset-game-btn-container');
        const statsSection = document.getElementById('stats-section'); // New stats section

        const newPlayerInput = document.getElementById('newPlayer');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const playersListContainer = document.getElementById('players-list-container');
        const playersList = document.getElementById('players-list');
        const gameModeSelect = document.getElementById('gameMode');

        const x01RulesDiv = document.getElementById('x01-rules'); // New: 301/501 rules container
        const doubleInCheckbox = document.getElementById('doubleIn');
        const doubleOutCheckbox = document.getElementById('doubleOut');

        const atcRulesDiv = document.getElementById('atc-rules'); // New: ATC rules container
        const atcAllowSimpleCheckbox = document.getElementById('atcAllowSimple');
        const atcAllowDoubleCheckbox = document.getElementById('atcAllowDouble');
        const atcAllowTripleCheckbox = document.getElementById('atcAllowTriple');

        const enableVoiceCheckbox = document.getElementById('enableVoice'); // New checkbox
        const startGameBtn = document.getElementById('startGameBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        const newGameWinnerBtn = document.getElementById('newGameWinnerBtn');
        const showStatsBtn = document.getElementById('showStatsBtn'); // New stats button
        const backToMainFromStatsBtn = document.getElementById('backToMainFromStatsBtn'); // New back button

        const gameModeDisplay = document.getElementById('game-mode-display');
        const playerScoresDisplay = document.getElementById('player-scores-display');
        const currentPlayerNameDisplay = document.getElementById('current-player-name');
        const dartsCountDisplay = document.getElementById('darts-count');
        const currentDartsDisplay = document.getElementById('current-darts-display');
        const selectedMultiplierDisplay = document.getElementById('selected-multiplier-display');
        const multiplierSimpleBtn = document.getElementById('multiplier-simple');
        const multiplierDoubleBtn = document.getElementById('multiplier-double');
        const multiplierTripleBtn = document.getElementById('multiplier-triple');
        const numberKeypad = document.getElementById('number-keypad');
        const undoLastDartBtn = document.getElementById('undoLastDartBtn');
        const winnerNameDisplay = document.getElementById('winner-name');
        const historyContent = document.getElementById('history-content');
        const playerStatsSummary = document.getElementById('player-stats-summary'); // Stats summary container

        const numberButtons = [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
            25, 0 // Bullseye et Miss
        ];

        // Function to create a ripple effect on button click
        function createRipple(event) {
            const button = event.currentTarget;
            const circle = document.createElement('span');
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;

            circle.style.width = circle.style.height = `${diameter}px`;
            circle.style.left = `${event.clientX - (button.offsetLeft + radius)}px`;
            circle.style.top = `${event.clientY - (button.offsetTop + radius)}px`;
            circle.classList.add('ripple');

            const ripple = button.getElementsByClassName('ripple')[0];
            if (ripple) {
                ripple.remove();
            }
            button.appendChild(circle);
        }

        // Helper function to set messages and update UI
        function showMessage(msg) {
            message = msg;
            updateUI();
        }

        // Function to make the AI speak
        function speakMessage(text) {
            if (isVoiceActive && speechSynth) {
                speakingQueue.push(text);
                if (!isSpeaking) {
                    processSpeechQueue();
                }
            }
        }

        function processSpeechQueue() {
            if (speakingQueue.length > 0 && !isSpeaking) {
                isSpeaking = true;
                const text = speakingQueue.shift(); // Always a string now

                const utterance = new SpeechSynthesisUtterance(text);

                const maleFrenchVoice = voices.find(voice => voice.lang === 'fr-FR' && (voice.name.includes('male') || voice.name.includes('Male') || voice.name.includes('homme') || voice.name.includes('Homme')));
                const frenchVoice = voices.find(voice => voice.lang === 'fr-FR');

                if (maleFrenchVoice) {
                    utterance.voice = maleFrenchVoice;
                } else if (frenchVoice) {
                    utterance.voice = frenchVoice;
                }
                utterance.lang = 'fr-FR'; // Ensure language is set
                utterance.pitch = 1; // Default pitch
                utterance.rate = 1;  // Default rate

                utterance.onend = () => {
                    isSpeaking = false;
                    processSpeechQueue(); // Process next message in queue
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror', event);
                    isSpeaking = false;
                    processSpeechQueue(); // Try to process next message even on error
                };

                speechSynth.speak(utterance);
            }
        }


        // Functions to update UI
        function updateUI() {
            // Toggle sections visibility
            configSection.classList.toggle('hidden', gameStarted || winner || statsSection.classList.contains('active'));
            gameSection.classList.toggle('hidden', !gameStarted || winner || statsSection.classList.contains('active'));
            winnerSection.classList.toggle('hidden', !winner || statsSection.classList.contains('active'));
            messageSection.classList.toggle('hidden', !message);
            historySection.classList.toggle('hidden', !(gameStarted || winner) || players.length === 0 || statsSection.classList.contains('active'));
            resetGameBtnContainer.classList.toggle('hidden', !gameStarted && !winner);
            statsSection.classList.toggle('hidden', !statsSection.classList.contains('active')); // Manage stats section visibility

            // Update message
            messageText.textContent = message;

            // Update players list in config
            renderPlayersList();

            // Update game mode display
            let displayMode = gameMode;
            if (gameMode === 'atc') displayMode = 'Around the Clock';
            gameModeDisplay.textContent = `Jeu en Cours: ${displayMode}`;

            // Update player scores display
            renderPlayerScores();

            // Update current player info
            if (gameStarted && players.length > 0) {
                currentPlayerNameDisplay.textContent = players[currentPlayerIndex];
                dartsCountDisplay.textContent = currentDartsThrown.length;
                currentDartsDisplay.textContent = currentDartsThrown.length > 0 ?
                    currentDartsThrown.map(d => d.display).join(', ') : 'Aucune';
                selectedMultiplierDisplay.textContent = selectedMultiplier === 2 ? 'Double' : selectedMultiplier === 3 ? 'Triple' : 'Simple';

                // Update multiplier button styles
                multiplierSimpleBtn.classList.toggle('btn-info', selectedMultiplier === 1);
                multiplierSimpleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 1);
                multiplierSimpleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 1);

                multiplierDoubleBtn.classList.toggle('btn-info', selectedMultiplier === 2);
                multiplierDoubleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 2);
                multiplierDoubleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 2);

                multiplierTripleBtn.classList.toggle('btn-info', selectedMultiplier === 3);
                multiplierTripleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 3);
                multiplierTripleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 3);


                // Disable multiplier buttons if 3 darts thrown
                const disableMultiplierButtons = currentDartsThrown.length >= 3;
                multiplierSimpleBtn.disabled = disableMultiplierButtons;
                multiplierDoubleBtn.disabled = disableMultiplierButtons;
                multiplierTripleBtn.disabled = disableMultiplierButtons;
                multiplierSimpleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierSimpleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);
                multiplierDoubleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierDoubleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);
                multiplierTripleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierTripleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);

                // Disable number buttons if 3 darts thrown
                const disableNumberButtons = currentDartsThrown.length >= 3;
                numberKeypad.querySelectorAll('button').forEach(button => {
                    button.disabled = disableNumberButtons;
                    button.classList.toggle('opacity-50', disableNumberButtons);
                    button.classList.toggle('cursor-not-allowed', disableNumberButtons);
                });

                // Update undo button state
                undoLastDartBtn.disabled = currentDartsThrown.length === 0;
                undoLastDartBtn.classList.toggle('opacity-50', currentDartsThrown.length === 0);
                undoLastDartBtn.classList.toggle('cursor-not-allowed', currentDartsThrown.length === 0);
            }

            // Update winner display
            if (winner) {
                winnerNameDisplay.textContent = `${winner} a gagnÃ© le jeu !`;
            }

            // Update history display
            renderHistory();
        }

        function renderPlayersList() {
            playersList.innerHTML = ''; // Clear existing list
            console.log("Rendering players list. Players count:", players.length); // Debug log
            if (players.length > 0) {
                playersListContainer.classList.remove('hidden');
                players.forEach((player, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-gray-900 p-3 rounded-lg border border-gray-600 shadow-md';
                    li.innerHTML = `
                        <span class="text-lg text-gray-100">${player}</span>
                        <button
                            data-player="${player}"
                            class="bg-red-600 hover:bg-red-700 text-white p-2 rounded-full text-sm transition duration-300 ease-in-out transform hover:scale-110 flex items-center justify-center"
                            title="Supprimer le joueur"
                            aria-label="Supprimer le joueur ${player}"
                        >
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    playersList.appendChild(li);
                });
            } else {
                playersListContainer.classList.add('hidden');
            }
        }

        function renderPlayerScores() {
            playerScoresDisplay.innerHTML = ''; // Clear existing scores
            players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `p-4 rounded-lg shadow-xl text-center transition duration-300 ease-in-out transform ${
                    index === currentPlayerIndex ? 'bg-blue-600 border-blue-400 scale-105 player-card-active' : 'bg-gray-900 border-gray-600'
                }`;
                // Display score or ATC target
                let scoreDisplay = playerScores[player];
                if (atcMode) {
                    scoreDisplay = playerScores[player] === 25 ? 'BULL' : playerScores[player];
                }

                div.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-white">${player}</h3>
                    <p class="text-4xl font-extrabold text-green-400">${scoreDisplay}</p>
                    ${doubleInActive && !playerHasDoubledIn[player] && (gameMode === '301' || gameMode === '501') ? '<p class="text-sm text-yellow-200 mt-1">Doit faire un Double In !</p>' : ''}
                `;
                playerScoresDisplay.appendChild(div);
            });
        }

        function renderNumberKeypad() {
            numberKeypad.innerHTML = ''; // Clear existing buttons
            numberButtons.forEach(num => {
                const button = document.createElement('button');
                button.textContent = num;
                button.className = `p-3 rounded-lg text-xl font-bold btn-gradient btn-dark-gradient`;
                button.dataset.value = num; // Store the number value
                button.setAttribute('aria-label', `Entrer le score ${num}`);
                numberKeypad.appendChild(button);
            });
        }

        function renderHistory() {
            historyContent.innerHTML = ''; // Clear existing history
            players.forEach(player => {
                const playerHistoryDiv = document.createElement('div');
                playerHistoryDiv.className = 'bg-gray-900 p-4 rounded-lg border border-gray-600 shadow-md';
                // Ensure history[player] is an array before calling .map()
                const playerHistoryEntries = history[player] || []; // Provide an empty array if undefined
                playerHistoryDiv.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-yellow-200">${player}</h3>
                    <ul class="max-h-48 overflow-y-auto custom-scrollbar">
                        ${playerHistoryEntries.map((entry, index) => `
                            <li class="mb-1 text-gray-300 text-left">
                                <span class="font-bold text-white">Tour ${index + 1}:</span> FlÃ©chettes: <span class="text-blue-300">${entry.darts}</span>, Score total: <span class="text-green-300">${entry.scoreEntered}</span>, Nouveau total: <span class="text-purple-300">${entry.newTotal}</span>
                                ${entry.message ? `<span class="text-sm text-red-400 italic"> (${entry.message})</span>` : ''}
                            </li>
                        `).join('')}
                    </ul>
                `;
                historyContent.appendChild(playerHistoryDiv);
            });
        }

        // Game Logic Functions
        function addPlayer() {
            console.log("Add Player button clicked!"); // Debug log to confirm click
            const name = newPlayerInput.value.trim();
            console.log("Attempting to add player:", name); // Debug log

            if (name !== '' && !players.includes(name)) {
                players.push(name);
                // Initialize score and history for the new player immediately
                // For ATC, initial score is 1 (first target)
                playerScores[name] = (String(gameModeSelect.value).startsWith('atc')) ? 1 : parseInt(gameModeSelect.value, 10);
                history[name] = []; // Initialize with an empty array
                allDartsThrown[name] = []; // Initialize allDartsThrown for the player
                playerHasDoubledIn[name] = false; // Initialize double-in status
                newPlayerInput.value = '';
                showMessage(''); // Use showMessage
                console.log("Players array after adding:", players); // Debug log
                updateUI();
            } else if (name === '') {
                showMessage('Veuillez entrer un nom de joueur.'); // Use showMessage
            } else {
                showMessage('Ce joueur existe dÃ©jÃ .'); // Use showMessage
            }
        }

        function removePlayer(playerToRemove) {
            players = players.filter(player => player !== playerToRemove);
            delete playerScores[playerToRemove];
            delete history[playerToRemove];
            delete allDartsThrown[playerToRemove]; // Delete from allDartsThrown
            delete playerHasDoubledIn[playerToRemove];

            // Adjust current player index if needed
            if (players.length > 0) { // Only adjust if there are still players
                if (currentPlayerIndex >= players.length) { // If current index is out of bounds
                    currentPlayerIndex = 0; // Reset to first player
                }
            }
             else { // No players left
                resetGame();
                return;
            }
            showMessage(''); // Use showMessage
            updateUI();
        }

        function startGame() {
            if (players.length === 0) {
                showMessage('Veuillez ajouter au moins un joueur avant de commencer.'); // Use showMessage
                return;
            }
            gameStarted = true;
            winner = null;
            message = ''; // Clear message
            gameMode = gameModeSelect.value; // Get string value for ATC modes
            gameEnded = false; // Reset gameEnded for a new game

            doubleInActive = doubleInCheckbox.checked;
            doubleOutActive = doubleOutCheckbox.checked;
            isVoiceActive = enableVoiceCheckbox.checked; // Get voice setting

            // Determine ATC mode and allowed hit types based on config
            if (String(gameMode).startsWith('atc')) {
                atcMode = 'atc'; // Generic 'atc' mode
                atcAllowedHitTypes = {
                    simple: atcAllowSimpleCheckbox.checked,
                    double: atcAllowDoubleCheckbox.checked,
                    triple: atcAllowTripleCheckbox.checked
                };
                // Ensure at least one hit type is selected for ATC modes
                if (!atcAllowedHitTypes.simple && !atcAllowedHitTypes.double && !atcAllowedHitTypes.triple) {
                    showMessage('Pour le mode Around the Clock, veuillez sÃ©lectionner au moins un type de coup valide (Simple, Double ou Triple).');
                    gameStarted = false; // Prevent game from starting
                    updateUI();
                    return;
                }
            } else {
                atcMode = null;
                atcAllowedHitTypes = { simple: true, double: false, triple: false }; // Reset for X01 modes
            }

            // Initialize scores and double-in status for new game
            playerScores = {};
            history = {};
            allDartsThrown = {}; // Reset allDartsThrown for new game
            playerHasDoubledIn = {};
            players.forEach(player => {
                // For ATC, initial score is 1 (first target)
                playerScores[player] = atcMode ? 1 : parseInt(gameMode, 10);
                history[player] = [];
                allDartsThrown[player] = []; // Initialize for each player
                playerHasDoubledIn[player] = false;
            });
            currentPlayerIndex = 0;
            currentDartsThrown = [];
            selectedMultiplier = 1;

            updateUI();
            // Initial announcement for the first player
            let initialMessage = `Le jeu commence en mode ${gameMode}. C'est au tour de ${players[currentPlayerIndex]}.`;
            if (!atcMode && playerScores[players[currentPlayerIndex]] <= 170 && playerScores[players[currentPlayerIndex]] > 1) {
                initialMessage += ` Il vous reste ${playerScores[players[currentPlayerIndex]]} points.`;
            } else if (atcMode) {
                initialMessage += ` Votre cible est le numÃ©ro ${playerScores[players[currentPlayerIndex]] === 25 ? 'Bullseye' : playerScores[players[currentPlayerIndex]]}.`;
            }
            // Keep the initial AI comment for the very start of the game
            initialMessage += ` ${aiComments[Math.floor(Math.random() * aiComments.length)]}`;
            speakMessage(initialMessage);
        }

        function resetGame() {
            players = [];
            newPlayerName = '';
            gameMode = 501; // Reset to default 501
            playerScores = {};
            currentPlayerIndex = 0;
            gameStarted = false;
            winner = null;
            message = ''; // Clear message
            history = {};
            allDartsThrown = {}; // Reset allDartsThrown
            doubleInActive = false;
            doubleOutActive = false;
            playerHasDoubledIn = {};
            currentDartsThrown = [];
            selectedMultiplier = 1;
            atcMode = null; // Reset ATC mode
            atcAllowedHitTypes = { simple: false, double: false, triple: false }; // Reset ATC allowed hits to all unchecked
            gameEnded = false; // Reset global gameEnded state

            // Reset checkboxes and select
            gameModeSelect.value = 501;
            doubleInCheckbox.checked = false;
            doubleOutCheckbox.checked = false;
            enableVoiceCheckbox.checked = true; // Reset voice to active by default

            // Reset ATC specific checkboxes to unchecked
            atcAllowSimpleCheckbox.checked = false;
            atcAllowDoubleCheckbox.checked = false;
            atcAllowTripleCheckbox.checked = false;


            // Hide stats section if visible
            statsSection.classList.remove('active');

            updateUI();
            speakMessage("Jeu rÃ©initialisÃ©. Bienvenue aux flÃ©chettes !");
        }

        function submitTurn(dartsForThisTurn) {
            const currentPlayer = players[currentPlayerIndex];
            // Get the score at the very beginning of the turn. This is crucial for bust logic.
            // If it's the first turn, use the initial game mode score. Otherwise, use the last recorded score.
            const scoreAtStartOfTurn = history[currentPlayer].length > 0 ?
                                       history[currentPlayer][history[currentPlayer].length - 1].newTotal : parseInt(gameMode, 10);
            
            let finalScoreForPlayer = playerScores[currentPlayer]; // This is the score after live deductions from handleNumberClick.
            let pointsDeductedThisTurnForHistory = 0; // Actual points scored for history, considering rules.

            let winOccurred = false;
            let bustOccurred = false;
            let turnMessage = '';
            let aiVoiceMessages = [];

            // Add all darts thrown in this turn to the player's overall dart history for stats
            allDartsThrown[currentPlayer] = allDartsThrown[currentPlayer].concat(dartsForThisTurn);

            if (atcMode) {
                let numbersAdvancedInTurn = 0;
                let nextTargetToHit = scoreAtStartOfTurn; // Start from current target for ATC

                for (const dart of dartsForThisTurn) {
                    let hitCurrentTarget = false;
                    // Check if dart hits the current target and is of an allowed type
                    if (dart.value === nextTargetToHit) {
                        if (atcAllowedHitTypes.simple && dart.multiplier === 1) {
                            hitCurrentTarget = true;
                        } else if (atcAllowedHitTypes.double && dart.multiplier === 2) {
                            hitCurrentTarget = true;
                        } else if (atcAllowedHitTypes.triple && dart.multiplier === 3) {
                            hitCurrentTarget = true;
                        }
                    }

                    if (hitCurrentTarget) {
                        numbersAdvancedInTurn++;
                        nextTargetToHit++;
                        if (nextTargetToHit > 20 && nextTargetToHit < 25) { // After 20, next target is 25 (Bullseye)
                            nextTargetToHit = 25;
                        } else if (nextTargetToHit > 25) { // After hitting 25, game ends
                            gameEnded = true; // Update global gameEnded
                            break; // Stop processing darts if game ends
                        }
                    }
                }

                finalScoreForPlayer = nextTargetToHit; // Final update for ATC
                pointsDeductedThisTurnForHistory = numbersAdvancedInTurn; // For ATC, this is the number of targets advanced.

                if (gameEnded) {
                    turnMessage = `${currentPlayer} a gagnÃ© le Around the Clock !`;
                    winner = currentPlayer;
                    gameStarted = false;
                    aiVoiceMessages.push(`${currentPlayer} a gagnÃ© le Around the Clock ! FÃ©licitations !`);
                } else {
                    let commentCategory;
                    if (numbersAdvancedInTurn === 0) commentCategory = 'atc_0_progress';
                    else if (numbersAdvancedInTurn === 1) commentCategory = 'atc_1_progress';
                    else if (numbersAdvancedInTurn === 2) commentCategory = 'atc_2_progress';
                    else if (numbersAdvancedInTurn === 3) commentCategory = 'atc_3_progress';
                    else commentCategory = 'atc_4_plus_progress'; // For 4 or more

                    const turnSummary = `${currentPlayer} a avancÃ© de ${numbersAdvancedInTurn} numÃ©ro(s). ${getRandomComment(commentCategory)}`;
                    aiVoiceMessages.push(turnSummary);
                }

            } else { // 301/501 game mode logic
                // Re-evaluate the score based on rules from the scoreAtStartOfTurn
                let tempScoreForRulesCheck = scoreAtStartOfTurn;
                let tempPlayerHasDoubledInForRulesCheck = playerHasDoubledIn[currentPlayer];
                let actualPointsScoredThisTurn = 0; // The actual points that count towards the score deduction for this turn

                for (let i = 0; i < dartsForThisTurn.length; i++) {
                    const dart = dartsForThisTurn[i];
                    let dartScoreToConsider = dart.score;
                    let dartCounts = true;

                    // Double In check for this dart
                    if (doubleInActive && !tempPlayerHasDoubledInForRulesCheck) {
                        if (dart.multiplier === 2 && dart.value !== 0) {
                            tempPlayerHasDoubledInForRulesCheck = true;
                            aiVoiceMessages.push(`${currentPlayer} a rÃ©ussi son "Double In" !`);
                        } else {
                            dartCounts = false; // This dart doesn't count for score deduction
                            aiVoiceMessages.push(`FlÃ©chette ${i + 1} (${dart.display}) ne compte pas. ${currentPlayer} doit faire un Double In.`);
                        }
                    }

                    if (dartCounts) {
                        tempScoreForRulesCheck -= dartScoreToConsider;
                        actualPointsScoredThisTurn += dartScoreToConsider; // Accumulate actual points scored
                    }

                    // Check for bust/win after each *potentially counting* dart
                    if (dartCounts) {
                        if (tempScoreForRulesCheck < 0 || tempScoreForRulesCheck === 1) {
                            bustOccurred = true;
                            turnMessage = `${currentPlayer} a fait un "bust" ! Son score reste Ã  ${scoreAtStartOfTurn}.`;
                            aiVoiceMessages.push(turnMessage);
                            break; // Stop processing further darts
                        } else if (tempScoreForRulesCheck === 0) {
                            if (doubleOutActive) {
                                if (dart.multiplier === 2 && dart.value !== 0) { // Must be a double to finish
                                    winOccurred = true;
                                    turnMessage = `${currentPlayer} a gagnÃ© avec un "Double Out" !`;
                                    winner = currentPlayer;
                                    gameStarted = false;
                                    gameEnded = true;
                                    aiVoiceMessages.push(`${currentPlayer} a gagnÃ© avec un Double Out ! FÃ©licitations !`);
                                    break;
                                } else { // Hit 0 but not with a double when Double Out is active
                                    bustOccurred = true;
                                    turnMessage = `${currentPlayer} a fait un "bust" ! Doit terminer avec un "Double Out". Son score reste Ã  ${scoreAtStartOfTurn}.`;
                                    aiVoiceMessages.push(turnMessage);
                                    break;
                                }
                            } else { // Straight Out (no double out rule)
                                winOccurred = true;
                                turnMessage = `${currentPlayer} a gagnÃ© avec un "Straight Out" !`;
                                winner = currentPlayer;
                                gameStarted = false;
                                gameEnded = true;
                                aiVoiceMessages.push(`${currentPlayer} a gagnÃ© avec un Straight Out ! Bravo !`);
                                break;
                            }
                        }
                    }
                }

                // Apply the final score based on the rules check
                if (bustOccurred) {
                    finalScoreForPlayer = scoreAtStartOfTurn; // Revert score
                    pointsDeductedThisTurnForHistory = 0; // No points effectively deducted for a bust
                } else if (winOccurred) {
                    finalScoreForPlayer = 0; // Set to 0
                } else {
                    finalScoreForPlayer = tempScoreForRulesCheck; // Apply the calculated score
                    pointsDeductedThisTurnForHistory = actualPointsScoredThisTurn; // Use the actual points scored for history

                    // Add turn summary and funny comment for 301/501 if game not ended by win/bust
                    let commentCategory;
                    if (pointsDeductedThisTurnForHistory <= 40) commentCategory = 'low';
                    else if (pointsDeductedThisTurnForHistory <= 80) commentCategory = 'medium';
                    else if (pointsDeductedThisTurnForHistory <= 120) commentCategory = 'good';
                    else if (pointsDeductedThisTurnForHistory <= 179) commentCategory = 'high';
                    else if (pointsDeductedThisTurnForHistory === 180) commentCategory = '180';
                    else commentCategory = 'low'; // Fallback

                    if (pointsDeductedThisTurnForHistory === 0 && dartsForThisTurn.length > 0 && doubleInActive && !playerHasDoubledIn[currentPlayer]) {
                        commentCategory = 'low'; // Treat as a very low score if no points due to Double In
                    }

                    const turnSummary = `${currentPlayer} a fait ${pointsDeductedThisTurnForHistory} points. ${getRandomComment(commentCategory)}`;
                    aiVoiceMessages.push(turnSummary);
                }
                // Update playerHasDoubledIn state for the player for the next turn
                playerHasDoubledIn[currentPlayer] = tempPlayerHasDoubledInForRulesCheck;
            }

            // Update the player's official score
            playerScores[currentPlayer] = finalScoreForPlayer;

            // Update history for this turn
            history[currentPlayer].push({
                darts: dartsForThisTurn.map(d => d.display).join(', '),
                scoreEntered: atcMode ? pointsDeductedThisTurnForHistory : pointsDeductedThisTurnForHistory, // For ATC, scoreEntered is number of darts advanced
                newTotal: playerScores[currentPlayer], // This is the actual new score/target after the turn
                message: turnMessage
            });

            // Reset current turn state for next player
            currentDartsThrown = [];
            selectedMultiplier = 1;
            showMessage(turnMessage); // Update visual message on screen

            // Speak all accumulated messages sequentially
            aiVoiceMessages.forEach(msg => speakMessage(msg));

            // Move to next player if game is not ended
            if (!gameEnded) {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length; // Advance to next player
                updateUI(); // Update UI to show next player immediately

                const nextPlayerName = players[currentPlayerIndex];
                const nextPlayerScore = playerScores[nextPlayerName];

                let msg = `C'est au tour de ${nextPlayerName}.`;
                if (!atcMode && nextPlayerScore <= 170 && nextPlayerScore > 1) { // Announce remaining score for 301/501
                    msg += ` Il vous reste ${nextPlayerScore} points.`;
                } else if (atcMode) { // Announce next target for ATC
                    msg += ` Votre cible est le numÃ©ro ${nextPlayerScore === 25 ? 'Bullseye' : nextPlayerScore}.`;
                }
                // Removed: msg += ` ${aiComments[Math.floor(Math.random() * aiComments.length)]}`; // This line is removed as per request
                speakMessage(msg); // Add next turn announcement to speech queue
            } else {
                updateUI(); // Update UI immediately if game ended (winner screen)
            }
        }

        function handleMultiplierClick(multiplier) {
            if (currentDartsThrown.length >= 3) {
                showMessage('Vous avez dÃ©jÃ  lancÃ© 3 flÃ©chettes pour ce tour.');
                updateUI();
                return;
            }
            selectedMultiplier = multiplier;
            showMessage('');
            updateUI();
        }

        function handleNumberClick(event) {
            const num = parseInt(event.target.dataset.value, 10);
            const currentPlayer = players[currentPlayerIndex];

            if (winner || !gameStarted) {
                showMessage("Le jeu est terminÃ© ou n'a pas commencÃ©.");
                updateUI();
                return;
            }

            if (currentDartsThrown.length >= 3) {
                showMessage('Vous avez dÃ©jÃ  lancÃ© 3 flÃ©chettes pour ce tour.');
                updateUI();
                return;
            }

            // Specific validation for bullseye and triples
            if (num === 25 && selectedMultiplier === 3) {
                showMessage('Le Bullseye (25) ne peut pas Ãªtre un Triple. Veuillez choisir Double ou Simple.');
                updateUI();
                return;
            }
            if (num === 0 && selectedMultiplier !== 1) {
                showMessage('Un "miss" (0) ne peut pas Ãªtre un Double ou Triple.');
                updateUI();
                return;
            }

            const displayMultiplier = selectedMultiplier === 2 ? 'D' : selectedMultiplier === 3 ? 'T' : '';
            const dartScore = num * selectedMultiplier;

            const newDart = {
                value: num,
                multiplier: selectedMultiplier,
                score: dartScore,
                display: `${displayMultiplier}${num}`
            };

            // Get the score at the very beginning of the current turn for accurate simulation
            const scoreAtStartOfTurn = history[currentPlayer].length > 0 ?
                                       history[currentPlayer][history[currentPlayer].length - 1].newTotal : parseInt(gameMode, 10);
            
            // Simulate the score deduction for live display and early submission check
            let simulatedScoreForLiveDisplay = scoreAtStartOfTurn;
            let tempPlayerHasDoubledInForLiveCheck = playerHasDoubledIn[currentPlayer];

            let currentDartsPlusNew = [...currentDartsThrown, newDart]; // All darts for this turn including the new one

            for (const dart of currentDartsPlusNew) {
                let scoreToDeductInSimulation = dart.score;
                if (doubleInActive && !tempPlayerHasDoubledInForLiveCheck) {
                    if (dart.multiplier === 2 && dart.value !== 0) {
                        tempPlayerHasDoubledInForLiveCheck = true;
                    } else {
                        scoreToDeductInSimulation = 0;
                    }
                }
                simulatedScoreForLiveDisplay -= scoreToDeductInSimulation;
            }

            // Update playerScores for live display only in X01 modes
            if (!atcMode) {
                playerScores[currentPlayer] = simulatedScoreForLiveDisplay;
            }
            // For ATC, playerScores is the target, not a running total, so no live deduction is needed here.

            // Add the dart to currentDartsThrown (this is the actual list of darts for the turn)
            currentDartsThrown.push(newDart);

            // Reset multiplier for the next dart input
            selectedMultiplier = 1;
            showMessage(''); // Clear message

            // Check for early submission if 3 darts are thrown or if a win/bust condition is met
            let shouldSubmitEarly = false;
            if (!atcMode) { // Only for 301/501 modes
                if (simulatedScoreForLiveDisplay < 0 || simulatedScoreForLiveDisplay === 1) { // Bust
                    shouldSubmitEarly = true;
                } else if (simulatedScoreForLiveDisplay === 0) { // Potential win
                    const lastAddedDart = newDart; // The most recently added dart
                    if (doubleOutActive) {
                        if (lastAddedDart.multiplier === 2 && lastAddedDart.value !== 0) {
                            shouldSubmitEarly = true;
                        }
                    } else { // Straight out win
                        shouldSubmitEarly = true;
                    }
                }
            }

            if (shouldSubmitEarly || currentDartsThrown.length === 3) {
                submitTurn(currentDartsThrown);
            } else {
                updateUI(); // Update UI to show new dart and live score for X01
            }
        }

        function undoLastDart() {
            if (currentDartsThrown.length > 0) {
                if (!gameStarted && winner) {
                    showMessage("Le jeu est terminÃ©. Impossible d'annuler.");
                    updateUI();
                    return;
                }

                const removedDart = currentDartsThrown.pop();
                const currentPlayer = players[currentPlayerIndex];

                // Recalculate the live score after undoing the dart
                const scoreAtStartOfTurn = history[currentPlayer].length > 0 ?
                                           history[currentPlayer][history[currentPlayer].length - 1].newTotal : parseInt(gameMode, 10);
                
                let simulatedScoreAfterUndo = scoreAtStartOfTurn;
                let tempPlayerHasDoubledInAfterUndo = playerHasDoubledIn[currentPlayer];

                for (const dart of currentDartsThrown) { // Iterate through remaining darts
                    let scoreToDeductInSimulation = dart.score;
                    if (doubleInActive && !tempPlayerHasDoubledInAfterUndo) {
                        if (dart.multiplier === 2 && dart.value !== 0) {
                            tempPlayerHasDoubledInAfterUndo = true;
                        } else {
                            scoreToDeductInSimulation = 0;
                        }
                    }
                    simulatedScoreAfterUndo -= scoreToDeductInSimulation;
                }

                // Update playerScores for live display in X01 modes
                if (!atcMode) {
                    playerScores[currentPlayer] = simulatedScoreAfterUndo;
                }
                // For ATC mode, no score change happens per dart, so no reversion needed.

                selectedMultiplier = 1;
                showMessage('');
                updateUI();
            } else {
                showMessage('Aucune flÃ©chette Ã  annuler pour ce tour.');
                updateUI();
            }
        }

        // --- Statistics Functions ---
        function showStatsPage() {
            statsSection.classList.add('active'); // Activate stats section
            updateUI(); // Hide other sections and show stats
            renderPlayerStats();
        }

        function renderPlayerStats() {
            playerStatsSummary.innerHTML = ''; // Clear previous stats

            players.forEach(player => {
                const playerStatDiv = document.createElement('div');
                playerStatDiv.className = 'bg-gray-900 p-4 rounded-lg border border-gray-600 shadow-md';

                let totalScoreSum = 0;
                let turnCount = 0;
                let totalDarts = 0;
                let hitSegments = {}; // { '20': { simple: 5, double: 2, triple: 1 }, '1': { ... } }

                // Calculate average score per turn (only for 301/501)
                if (!atcMode) {
                    history[player].forEach(turn => {
                        // Only count turns where points were deducted (not busts that revert score)
                        if (turn.scoreEntered > 0 || (turn.newTotal === 0 && turn.scoreEntered > 0)) { // Include winning turns
                            totalScoreSum += turn.scoreEntered;
                            turnCount++;
                        }
                    });
                }
                
                // Collect all darts for dartboard visualization
                allDartsThrown[player].forEach(dart => {
                    totalDarts++;
                    const segmentKey = dart.value.toString();
                    if (!hitSegments[segmentKey]) {
                        hitSegments[segmentKey] = { simple: 0, double: 0, triple: 0 };
                    }
                    if (dart.multiplier === 1) hitSegments[segmentKey].simple++;
                    else if (dart.multiplier === 2) hitSegments[segmentKey].double++;
                    else if (dart.multiplier === 3) hitSegments[segmentKey].triple++;
                });

                const averageScore = turnCount > 0 ? (totalScoreSum / turnCount).toFixed(2) : 'N/A';

                playerStatDiv.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-yellow-200">${player}</h3>
                    ${!atcMode ? `<p class="text-lg text-gray-300">Score moyen par tour: <span class="font-bold text-green-400">${averageScore}</span></p>` : ''}
                    <p class="text-lg text-gray-300">Total flÃ©chettes lancÃ©es: <span class="font-bold text-blue-400">${totalDarts}</span></p>
                    <h4 class="text-lg font-semibold mt-4 mb-2 text-purple-300">Zones touchÃ©es:</h4>
                    <canvas id="dartboardCanvas-${player}" width="200" height="200" class="bg-gray-800 rounded-md"></canvas>
                `;
                playerStatsSummary.appendChild(playerStatDiv);

                // Draw dartboard for each player
                drawDartboard(document.getElementById(`dartboardCanvas-${player}`), hitSegments);
            });
        }

        function drawDartboard(canvas, hitSegments) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = canvas.width / 2 - 10; // Max radius with some padding

            // Define dartboard ring radii (simplified for visualization)
            const bullseyeRadius = maxRadius * 0.08;
            const outerBullRadius = maxRadius * 0.16;
            const singleInnerRing = maxRadius * 0.5;
            const tripleRing = maxRadius * 0.55;
            const tripleOuterRing = maxRadius * 0.65;
            const doubleRing = maxRadius * 0.95;
            const doubleOuterRing = maxRadius * 1.0;

            // Segment values in dartboard order (clockwise from 20)
            const segmentOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

            // Function to get color based on hit count
            function getHitColor(count) {
                if (count === 0) return 'rgba(50, 50, 50, 0.2)'; // Very light, almost transparent
                if (count < 3) return 'rgba(255, 255, 0, 0.4)'; // Yellow, low hits
                if (count < 7) return 'rgba(255, 165, 0, 0.6)'; // Orange, medium hits
                if (count < 15) return 'rgba(255, 69, 0, 0.8)'; // Red-orange, high hits
                return 'rgba(255, 0, 0, 1)'; // Red, very high hits
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw segments and fill based on hits
            for (let i = 0; i < 20; i++) {
                const startAngle = (Math.PI / 10) * i - Math.PI / 20; // Adjust for segment 20 at top
                const endAngle = (Math.PI / 10) * (i + 1) - Math.PI / 20;
                const segmentValue = segmentOrder[i];

                // Draw Outer Single (between triple and double)
                ctx.beginPath();
                ctx.arc(centerX, centerY, tripleRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * singleInnerRing, centerY + Math.sin(endAngle) * singleInnerRing);
                ctx.arc(centerX, centerY, singleInnerRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].simple : 0); // Color based on simple hits
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Triple Ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, tripleOuterRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * tripleRing, centerY + Math.sin(endAngle) * tripleRing);
                ctx.arc(centerX, centerY, tripleRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].triple : 0); // Color based on triple hits
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Double Ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, doubleOuterRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * doubleRing, centerY + Math.sin(endAngle) * doubleRing);
                ctx.arc(centerX, centerY, doubleRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].double : 0); // Color based on double hits
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw Outer Bull (25)
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerBullRadius, 0, Math.PI * 2);
            ctx.fillStyle = getHitColor(hitSegments['25'] ? hitSegments['25'].simple : 0);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw Bullseye (Inner Bull) (25)
            ctx.beginPath();
            ctx.arc(centerX, centerY, bullseyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = getHitColor(hitSegments['25'] ? hitSegments['25'].double : 0); // Assuming inner bull is D-Bull
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Add labels (optional, can clutter small canvas)
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // For a small canvas, labels might be too much.
            // If needed, calculate positions for 20, 15, etc.
        }


        function hideStatsPage() {
            statsSection.classList.remove('active');
            updateUI(); // Show appropriate sections
        }

        // Function to update rule options visibility based on game mode
        function updateRuleOptionsVisibility() {
            const selectedMode = gameModeSelect.value;
            if (selectedMode === 'atc') { // Check for the generic 'atc' mode
                x01RulesDiv.classList.add('hidden');
                atcRulesDiv.classList.remove('hidden');
                // Set default checked state for ATC options to all unchecked
                atcAllowSimpleCheckbox.checked = false;
                atcAllowDoubleCheckbox.checked = false;
                atcAllowTripleCheckbox.checked = false;
            } else { // For 301/501 modes
                x01RulesDiv.classList.remove('hidden');
                atcRulesDiv.classList.add('hidden');
            }
        }


        // Event Listeners for new buttons
        showStatsBtn.addEventListener('click', showStatsPage);
        backToMainFromStatsBtn.addEventListener('click', hideStatsPage);

        // Event Listeners for existing buttons
        addPlayerBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            addPlayer();
        });
        startGameBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            startGame();
        });
        resetGameBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            resetGame();
        });
        newGameWinnerBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            resetGame();
        });
        undoLastDartBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            undoLastDart();
        });

        multiplierSimpleBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            handleMultiplierClick(1);
        });
        multiplierDoubleBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            handleMultiplierClick(2);
        });
        multiplierTripleBtn.addEventListener('click', (event) => {
            createRipple(event); // Add ripple effect
            handleMultiplierClick(3);
        });

        // Event listener for number keypad buttons (delegation)
        numberKeypad.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON' && event.target.dataset.value !== undefined) {
                createRipple(event); // Add ripple effect
                handleNumberClick(event);
            }
        });

        // Event listener for removing players from the list
        playersList.addEventListener('click', (event) => {
            if (event.target.closest('button') && event.target.closest('button').dataset.player) {
                createRipple(event); // Add ripple effect
                const playerToRemove = event.target.closest('button').dataset.player;
                removePlayer(playerToRemove);
            }
        });

        // New event listener for game mode selection change
        gameModeSelect.addEventListener('change', updateRuleOptionsVisibility);

        // Initial render on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Script loaded and DOMContentLoaded."); // Debug log
            renderNumberKeypad(); // Render number buttons once
            updateRuleOptionsVisibility(); // Call initially to set correct visibility
            updateUI(); // Initial UI update
        });

    </script>
</body>
</html>
