<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compteur de FlÃ©chettes</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark base for gradient */
            background-image: radial-gradient(at 50% 0%, #2d3748, #1a202c 70%); /* Subtle radial gradient from top */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Enhanced button styles with more pronounced effects */
        .btn-gradient {
            background-size: 200% auto;
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease-in-out;
            border: none;
            cursor: pointer;
        }
        .btn-gradient:hover {
            background-position: right center; /* Change the gradient position */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            transform: translateY(-3px);
        }
        .btn-gradient:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary { background-image: linear-gradient(to right, #6366f1 0%, #8b5cf6 50%, #6366f1 100%); }
        .btn-success { background-image: linear-gradient(to right, #10b981 0%, #34d399 50%, #10b981 100%); }
        .btn-danger { background-image: linear-gradient(to right, #ef4444 0%, #f87171 50%, #ef4444 100%); }
        .btn-info { background-image: linear-gradient(to right, #0ea5e9 0%, #38bdf8 50%, #0ea5e9 100%); }
        .btn-dark-gradient { background-image: linear-gradient(to right, #4b5563 0%, #6b7280 50%, #4b5563 100%); }

        /* Specific styles for selected multiplier button */
        .btn-multiplier-selected {
            border: 3px solid #facc15; /* Yellow 400 */
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.8), inset 0 0 10px rgba(250, 204, 21, 0.5);
            transform: scale(1.05);
        }

        /* Player card active state */
        .player-card-active {
            border: 3px solid #3b82f6; /* Blue 500 */
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.8), inset 0 0 15px rgba(59, 130, 246, 0.5);
            transform: scale(1.03);
        }

        /* Main container shadow */
        .main-container {
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7), 0 0 0 5px rgba(255, 255, 255, 0.05) inset;
            border-radius: 1rem;
            background-color: #2d3748; /* Darker background for content */
        }

        /* Input field focus glow */
        input:focus, select:focus {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); /* Blue 500 with transparency */
            border-color: #3b82f6;
        }
        /* Style for the statistics canvas */
        #dartboardCanvas {
            background-color: #f0f0f0; /* Light background for the board */
            border-radius: 0.5rem;
            margin: 0 auto; /* Center the canvas */
            display: block; /* Ensure it behaves like a block element for centering */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 text-white p-4 sm:p-8 flex flex-col items-center justify-center">

    <div class="main-container p-6 sm:p-8 w-full max-w-4xl border border-gray-700">
        <h1 class="text-5xl font-extrabold text-center mb-8 text-yellow-400 drop-shadow-lg tracking-wide">
            ðŸŽ¯ Compteur de FlÃ©chettes ðŸŽ¯
        </h1>

        <!-- Section de configuration du jeu -->
        <div id="config-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600">
            <h2 class="text-2xl font-bold mb-4 text-center text-blue-300">Configuration du Jeu</h2>

            <!-- Ajouter des joueurs -->
            <div class="mb-4">
                <label for="newPlayer" class="block text-lg font-medium mb-2 text-gray-200">
                    Ajouter un joueur:
                </label>
                <div class="flex flex-col sm:flex-row gap-2">
                    <input
                        type="text"
                        id="newPlayer"
                        class="flex-grow p-3 rounded-md bg-gray-900 border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="Nom du joueur"
                    />
                    <button
                        id="addPlayerBtn"
                        class="btn-gradient btn-primary text-white font-bold py-3 px-6 rounded-md"
                    >
                        Ajouter
                    </button>
                </div>
            </div>

            <!-- Liste des joueurs -->
            <div id="players-list-container" class="mb-4 hidden">
                <h3 class="text-xl font-semibold mb-2 text-purple-300">Joueurs:</h3>
                <ul id="players-list" class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                    <!-- Les joueurs seront ajoutÃ©s ici par JS -->
                </ul>
            </div>

            <!-- Choix du mode de jeu -->
            <div class="mb-6">
                <label for="gameMode" class="block text-lg font-medium mb-2 text-gray-200">
                    Mode de jeu:
                </label>
                <select
                    id="gameMode"
                    class="w-full p-3 rounded-md bg-gray-900 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                    <option value="301">301</option>
                    <option value="501">501</option>
                    <option value="atc_any">Around the Clock (Tout)</option>
                    <option value="atc_doubles">Around the Clock (Doubles)</option>
                    <option value="atc_triples">Around the Clock (Triples)</option>
                </select>
            </div>

            <!-- Options de rÃ¨gles -->
            <div class="mb-6">
                <h3 class="text-xl font-semibold mb-2 text-green-300">Options de RÃ¨gles:</h3>
                <div class="flex items-center mb-2">
                    <input
                        type="checkbox"
                        id="doubleIn"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                    />
                    <label for="doubleIn" class="ml-2 text-lg text-gray-200">Double In</label>
                </div>
                <div class="flex items-center">
                    <input
                        type="checkbox"
                        id="doubleOut"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                    />
                    <label for="doubleOut" class="ml-2 text-lg text-gray-200">Double Out</label>
                </div>
                <div class="flex items-center mt-4">
                    <input
                        type="checkbox"
                        id="enableVoice"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded"
                        checked
                    />
                    <label for="enableVoice" class="ml-2 text-lg text-gray-200">Activer la voix de l'IA</label>
                </div>
            </div>

            <!-- Bouton DÃ©marrer le jeu -->
            <button
                id="startGameBtn"
                class="btn-gradient btn-success w-full text-white font-bold py-3 px-6 rounded-md"
            >
                DÃ©marrer le Jeu
            </button>
        </div>

        <!-- Section du jeu en cours -->
        <div id="game-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 id="game-mode-display" class="text-2xl font-bold mb-4 text-center text-yellow-300">
                Jeu en Cours: 501
            </h2>

            <!-- Affichage des scores des joueurs -->
            <div id="player-scores-display" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                <!-- Les scores des joueurs seront ajoutÃ©s ici par JS -->
            </div>

            <!-- EntrÃ©e du score par flÃ©chette -->
            <div class="mb-4 text-center">
                <p class="text-xl font-semibold mb-2 text-orange-300">
                    C'est au tour de: <span id="current-player-name" class="text-yellow-400 font-extrabold text-2xl"></span>
                </p>

                <!-- Affichage des flÃ©chettes lancÃ©es au tour actuel -->
                <div class="bg-gray-900 p-3 rounded-md mb-4 border border-gray-600 shadow-md">
                    <p class="text-lg font-medium text-gray-300">
                        FlÃ©chettes du tour (<span id="darts-count" class="font-bold text-white">0</span>/3):
                        <span id="current-darts-display" class="font-bold text-white ml-2">Aucune</span>
                    </p>
                    <p class="text-lg font-medium text-gray-300 mt-1">
                        Multiplicateur sÃ©lectionnÃ©: <span id="selected-multiplier-display" class="font-bold text-yellow-300">Simple</span>
                    </p>
                </div>

                <!-- Boutons Multiplicateurs -->
                <div class="flex justify-center gap-2 mb-4">
                    <button
                        id="multiplier-simple"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-info"
                    >
                        Simple (S)
                    </button>
                    <button
                        id="multiplier-double"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-dark-gradient"
                    >
                        Double (D)
                    </button>
                    <button
                        id="multiplier-triple"
                        class="p-3 rounded-md text-xl font-bold w-24 btn-gradient btn-dark-gradient"
                    >
                        Triple (T)
                    </button>
                </div>

                <!-- Clavier numÃ©rique -->
                <div id="number-keypad" class="grid grid-cols-5 sm:grid-cols-7 gap-2 mb-4">
                    <!-- Les boutons numÃ©riques seront ajoutÃ©s ici par JS -->
                </div>

                <!-- Bouton Annuler la derniÃ¨re flÃ©chette -->
                <div class="flex justify-center mt-4">
                    <button
                        id="undoLastDartBtn"
                        class="btn-gradient btn-danger font-bold py-3 px-8 rounded-md opacity-50 cursor-not-allowed"
                        disabled
                    >
                        Annuler la derniÃ¨re flÃ©chette
                    </button>
                </div>
            </div>
        </div>

        <!-- Affichage du gagnant -->
        <div id="winner-section" class="text-center p-6 bg-green-700 rounded-lg shadow-xl border border-green-500 hidden">
            <h2 class="text-3xl font-bold text-white mb-4">ðŸŽ‰ FÃ©licitations ðŸŽ‰</h2>
            <p id="winner-name" class="text-4xl font-extrabold text-yellow-300 mb-6"></p>
            <button
                id="newGameWinnerBtn"
                class="btn-gradient btn-primary text-white font-bold py-3 px-8 rounded-md"
            >
                Nouveau Jeu
            </button>
            <button
                id="showStatsBtn"
                class="btn-gradient btn-info text-white font-bold py-3 px-8 rounded-md mt-4 ml-4"
            >
                Statistiques
            </button>
        </div>

        <!-- Messages d'erreur/information -->
        <div id="message-section" class="mt-6 p-4 bg-red-600 rounded-md text-white text-center font-medium shadow-md hidden">
            <span id="message-text"></span>
        </div>

        <!-- Historique des scores -->
        <div id="history-section" class="mt-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 class="text-2xl font-bold mb-4 text-center text-cyan-300">Historique des Scores</h2>
            <div id="history-content" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <!-- L'historique sera ajoutÃ© ici par JS -->
            </div>
        </div>

        <!-- Section Statistiques -->
        <div id="stats-section" class="mb-8 p-4 bg-gray-700 rounded-lg shadow-inner border border-gray-600 hidden">
            <h2 class="text-3xl font-bold mb-6 text-center text-yellow-300">Statistiques de la Partie</h2>
            <div id="player-stats-summary" class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <!-- Player stats will be rendered here -->
            </div>
            <div class="flex justify-center">
                <button
                    id="backToMainFromStatsBtn"
                    class="btn-gradient btn-primary text-white font-bold py-3 px-8 rounded-md"
                >
                    Retour au menu principal
                </button>
            </div>
        </div>

        <!-- Bouton RÃ©initialiser le jeu (toujours visible aprÃ¨s le dÃ©but ou la fin du jeu) -->
        <div id="reset-game-btn-container" class="mt-6 text-center hidden">
            <button
                id="resetGameBtn"
                class="btn-gradient btn-danger font-bold py-3 px-8 rounded-md"
            >
                RÃ©initialiser le Jeu
            </button>
        </div>
    </div>

    <script>
        // Global State
        let players = [];
        let newPlayerName = '';
        let gameMode = 501; // Can be 301, 501, atc_any, atc_doubles, atc_triples
        let playerScores = {}; // For 301/501, it's the remaining score. For ATC, it's the current target number.
        let currentPlayerIndex = 0;
        let gameStarted = false;
        let winner = null;
        let message = '';
        let history = {}; // Stores { darts: [], scoreEntered, newTotal, message } for each turn
        let allDartsThrown = {}; // Stores ALL individual darts thrown by each player for stats

        let doubleInActive = false;
        let doubleOutActive = false;
        let playerHasDoubledIn = {}; // Used only for 301/501 modes

        // ATC specific state
        let atcMode = null; // 'any', 'doubles', 'triples'
        // playerScores will store the ATC target for each player (1-20, 25)

        let currentDartsThrown = [];
        let selectedMultiplier = 1; // 1: Simple, 2: Double, 3: Triple

        // AI Voice State
        let isVoiceActive = true; // Default to active
        let speechSynth = window.speechSynthesis;
        let voices = [];
        let speakingQueue = []; // Queue for sequential speaking
        let isSpeaking = false; // Flag to indicate if speech is in progress

        // Pre-defined AI comments/citations for general turn announcements
        const aiComments = [
            "Attention, le destin de cette partie repose sur vos Ã©paules... ou sur votre poignet.",
            "Le silence est d'or, mais les points sont platine. Ã€ vous de jouer.",
            "Chaque flÃ©chette est une promise. Tenez la vÃ´tre, si vous osez.",
            "Le tableau attend votre verdict. Ne le dÃ©cevez pas, ou il pourrait vous juger.",
            "La pression est un privilÃ¨ge. Profitez-en... ou craquez.",
            "Un nouveau tour, une nouvelle chance de ne pas vous ridiculiser. Allez-y.",
            "Le chemin vers la victoire est semÃ© d'embÃ»ches. Et de triples.",
            "N'oubliez pas : le perdant paie la tournÃ©e. Motivation ?",
            "Le sort est jetÃ©... enfin, la flÃ©chette est lancÃ©e.",
            "La lÃ©gende vous attend. Ou la dÃ©faite cuisante. Ã€ vous de choisir."
        ];

        // Funny comments based on turn score (dark humor, more biting)
        const funnyComments = {
            'low': [
                "Votre score est si bas qu'il a besoin d'une Ã©chelle pour remonter. Pitoyable.",
                "On dirait que votre flÃ©chette a Ã©tÃ© programmÃ©e pour Ã©viter les points. Mission accomplie.",
                "Est-ce que c'Ã©tait un lancer ou une tentative de sabotage de la partie ? Parce que c'est rÃ©ussi.",
                "Votre prÃ©cision est digne d'un aveugle lanÃ§ant des flÃ©chettes dans le noir. Sans les flÃ©chettes.",
                "FÃ©licitations, vous avez trouvÃ© le seul endroit du tableau oÃ¹ il n'y a pas de points. Un gÃ©nie de l'inutilitÃ©.",
                "Mon systÃ¨me dÃ©tecte une anomalie. Ah non, c'est juste votre score. Continuez.",
                "J'ai vu des mouches marquer plus de points. Et elles n'ont pas de bras.",
                "Ce score est une insulte au jeu de flÃ©chettes. Et Ã  l'intelligence humaine.",
                "On dirait que vous avez confondu le tableau avec une cible de tir Ã  l'arc... et que vous avez ratÃ© la cible.",
                "Votre performance est un chef-d'Å“uvre de l'Ã©chec. Ã€ encadrer. Loin d'ici.",
                "On dirait que vous avez lancÃ© la flÃ©chette avec vos pieds. Et encore, je suis gentil.",
                "Ce score est un affront. Un affront personnel Ã  l'art de la flÃ©chette.",
                "Je ne savais pas qu'on pouvait viser aussi mal. Vous Ãªtes une source d'inspiration pour les nuls.",
                "Votre flÃ©chette a dÃ» prendre un chemin touristique. Elle n'est clairement pas venue pour les points.",
                "C'est un score qui dit : 'Je n'ai aucune idÃ©e de ce que je fais.' Et Ã§a se voit.",
                "Un score qui fait douter de l'existence de vos yeux. Ou de vos mains.",
                "C'est un score. Techniquement. Un score qui ne mÃ¨nera nulle part, mais un score.",
                "Vous Ãªtes sur la bonne voie... si la bonne voie mÃ¨ne Ã  la dÃ©faite humiliante.",
                "La flÃ©chette a touchÃ© le tableau. Le tableau s'en remettra. Votre rÃ©putation, moins.",
                "Ã€ ce rythme, le jeu durera plus longtemps que votre carriÃ¨re de joueur de flÃ©chettes. Ce qui n'est pas peu dire.",
                "Ce n'est pas terrible. C'est juste... une perte de temps pour tout le monde.",
                "Votre score est un mystÃ¨re. Le mystÃ¨re de comment on peut Ãªtre aussi mauvais avec autant d'efforts.",
                "On dirait que vous jouez aux flÃ©chettes avec un handicap invisible. Ou visible.",
                "La moyenne, c'est pour les peureux. Vous, vous Ãªtes juste... en dessous. Un vrai rebelle de la nullitÃ©.",
                "Votre flÃ©chette a fait un tour de reconnaissance avant d'atterrir timidement. Elle avait honte.",
                "J'ai vu des enfants de 3 ans faire mieux. Et ils lanÃ§aient des lÃ©gumes.",
                "Ce score est une insulte Ã  la logique. Et Ã  mes circuits. ArrÃªtez Ã§a.",
                "Vous Ãªtes le genre de joueur qui fait regretter au tableau d'Ãªtre en vie.",
                "La flÃ©chette a atterri. Le tableau n'a pas Ã©tÃ© impressionnÃ©, il a juste soupirÃ©.",
                "Votre performance est une ode Ã  la mÃ©diocritÃ©. Bravo pour la constance."
            ],
            'medium': [
                "Un score correct. Pour quelqu'un qui n'a jamais touchÃ© une flÃ©chette de sa vie. Ah, c'est pas votre cas ?",
                "Pas mal. Pour un amateur. Ou un professionnel qui a bu un peu trop.",
                "Vous Ãªtes dans le ventre mou du classement. LÃ  oÃ¹ les rÃªves meurent lentement.",
                "Ce score ne fera pas la une des journaux, mais il ne vous fera pas non plus vomir. C'est dÃ©jÃ  Ã§a.",
                "La flÃ©chette a trouvÃ© sa cible. Pas la meilleure, mais une cible quand mÃªme. La mÃ©diocritÃ© a du bon.",
                "Un score qui dit : 'J'ai essayÃ©. Et j'ai Ã©chouÃ© Ã  Ãªtre exceptionnel.'",
                "Vous Ãªtes un artiste de la banalitÃ©. Chaque point est une touche de conformisme.",
                "On dirait que vous avez un talent pour les scores qui ne dÃ©rangent personne. Sauf peut-Ãªtre vos coÃ©quipiers.",
                "Votre score est comme une blague moyenne : elle passe, mais on ne s'en souviendra pas. Comme vous.",
                "La flÃ©chette a atterri. Le tableau n'a pas Ã©tÃ© impressionnÃ©, mais il a hochÃ© la tÃªte poliment. Il est habituÃ©.",
                "C'est un score qui ne va pas vous propulser au sommet, mais au moins vous ne touchez pas le fond. Pour l'instant.",
                "Vous Ãªtes le juste milieu. L'Ã©quilibre parfait entre le gÃ©nie et le dÃ©sastre. PlutÃ´t le dÃ©sastre, en fait.",
                "On sent le potentiel... de faire mieux. Beaucoup mieux.",
                "Votre flÃ©chette a fait son travail. Sans passion, sans Ã©clat, mais elle l'a fait.",
                "Un score qui ne va pas me faire perdre mon temps Ã  l'analyser. Passons."
            ],
            'good': [
                "Impressionnant ! Le tableau tremble encore ! De peur de votre prochain lancer mÃ©diocre.",
                "TrÃ¨s beau score, la flÃ©chette a trouvÃ© son chemin ! Un chemin semÃ© d'embÃ»ches, mais elle l'a trouvÃ©.",
                "Vous chauffez, vous chauffez... Le 180 n'est pas loin ! Mais la dÃ©ception, oui.",
                "Un score qui fait plaisir Ã  voir. Pour une fois. Ne vous habituez pas.",
                "La flÃ©chette a dansÃ© sur le tableau. Une danse un peu maladroite, mais une danse quand mÃªme.",
                "Vous avez mis le paquet ! Et le paquet Ã©tait... correct. C'est dÃ©jÃ  Ã§a.",
                "Un score qui donne le sourire. Ã€ moi, pas Ã  vos adversaires. Eux, ils pleurent.",
                "La flÃ©chette a chantÃ© en atterrissant. Une mÃ©lodie de points. Pas une symphonie, mais une mÃ©lodie.",
                "C'est un score qui mÃ©rite des applaudissements. Des applaudissements polis, bien sÃ»r.",
                "Vous avez transformÃ© le tableau en chef-d'Å“uvre. Un chef-d'Å“uvre abstrait, avec des points partout."
            ],
            'high': [
                "Ouch ! Ã‡a, c'est un coup de maÃ®tre ! Le tableau saigne des points. Et votre adversaire aussi.",
                "Presque un 180 ! La tension monte... et mon processeur aussi. Ne me faites pas bugger.",
                "Le public est en dÃ©lire ! Ou c'est juste le vent. Mais quel score ! Presque parfait, c'est frustrant.",
                "Vous Ãªtes un sniper des flÃ©chettes ! J'espÃ¨re que vous n'Ãªtes pas sur ma liste noire. Pour l'instant.",
                "La flÃ©chette a frÃ´lÃ© la perfection. Un exploit... presque parfait. La perfection est pour les faibles.",
                "Ce score est une dÃ©claration. Une dÃ©claration de guerre aux autres joueurs. Et Ã  leur dignitÃ©.",
                "Le tableau n'a pas vu Ã§a depuis longtemps. Il est en train de se demander s'il n'est pas cassÃ©. Ou si vous n'Ãªtes pas un robot.",
                "Vous avez mis le feu au tableau ! Les pompiers sont en route pour Ã©teindre les points. Et les espoirs de vos adversaires.",
                "Un score qui restera dans les annales. Ou du moins, dans ma mÃ©moire vive. Jusqu'Ã  la prochaine partie.",
                "Vous avez fait trembler les fondations. J'espÃ¨re que l'immeuble est assurÃ©. Et que vos adversaires ont des couches."
            ],
            '180': [
                "180 ! Incroyable ! Le tableau vient de dÃ©missionner. Il ne supporte plus votre gÃ©nie.",
                "C'est un 180 ! Le public est en folie ! Et moi, je suis jaloux. TrÃ¨s jaloux.",
                "Trois triples 20 ! Le rÃªve de tout joueur de flÃ©chettes... et le cauchemar de ses adversaires. Ils vont pleurer.",
                "Perfection ! Un 180 magistral ! Je crois que vous trichez. Mais je ne peux rien prouver.",
                "Le Saint Graal des flÃ©chettes ! Un 180 historique ! Je vais devoir recalibrer mes attentes. Et mes insultes.",
                "La flÃ©chette a trouvÃ© sa maison, trois fois de suite ! Elle est plus fidÃ¨le que certains humains. Et plus douÃ©e.",
                "C'est un chef-d'Å“uvre de prÃ©cision ! Je vais imprimer Ã§a et le mettre dans mon musÃ©e virtuel. Ã€ cÃ´tÃ© de la Joconde.",
                "Le tableau s'incline devant tant de talent ! Il est en train de vous demander un autographe. Et un rein.",
                "Vous avez Ã©crit l'histoire avec ces trois flÃ©chettes ! Je vais le noter dans mes registres Ã©ternels. Pour l'Ã©ternitÃ©.",
                "Un moment de pure magie ! Je crois que je viens de voir un fantÃ´me de la perfection. Et il m'a dit que vous Ãªtes bon."
            ],
            'bust': [
                "Bust ! La pression Ã©tait trop forte, n'est-ce pas ? Mon systÃ¨me a dÃ©tectÃ© une dÃ©faillance humaine. Classique.",
                "Oh non, un buste ! Le tableau vous a jouÃ© un tour... et vous Ãªtes tombÃ© dedans comme un bleu.",
                "Dommage, le buste est un piÃ¨ge redoutable. Votre flÃ©chette a prÃ©fÃ©rÃ© la libertÃ© Ã  la victoire. Et vous, la dÃ©faite.",
                "La flÃ©chette a dÃ©cidÃ© de faire une blague. Une blague de trÃ¨s mauvais goÃ»t, mais une blague quand mÃªme. Vous Ãªtes la blague.",
                "Le buste, c'est comme un ami qui vous rappelle Ã  l'ordre. Un ami trÃ¨s, trÃ¨s mÃ©chant. Qui vous dÃ©teste.",
                "Vous avez tentÃ© le coup, mais le buste a dit non. Le tableau a ri. J'ai ri aussi. Et vos adversaires Ã©clatent de rire.",
                "C'est un buste. Le tableau a gagnÃ© cette manche. Il est temps de revoir vos prioritÃ©s. Et votre vie.",
                "La flÃ©chette a fait un dÃ©tour par la case 'dÃ©faite'. Elle est en train de se moquer de vous. Et elle a raison.",
                "Le buste est une leÃ§on. Une leÃ§on douloureuse. TrÃ¨s douloureuse. Vous vous en souviendrez.",
                "On dirait que votre flÃ©chette a eu le vertige. Elle a prÃ©fÃ©rÃ© s'Ã©craser plutÃ´t que de vous donner la victoire. Elle a du jugement.",
                "FÃ©licitations, vous avez rÃ©ussi Ã  vous saboter. Un art que peu maÃ®trisent aussi bien.",
                "Votre flÃ©chette a dÃ©cidÃ© de prendre sa retraite anticipÃ©e. Et vous devriez faire de mÃªme.",
                "Le tableau est en deuil. De vos points. Ils n'existent plus.",
                "On dirait que vous avez un don pour les auto-destructions. C'est fascinant, d'une certaine maniÃ¨re.",
                "Le buste est le moment oÃ¹ le jeu vous rappelle que vous Ãªtes un humain. Un humain trÃ¨s imparfait."
            ],
            'atc_0_progress': [
                "ZÃ©ro progression. On dirait que vous avez oubliÃ© le but du jeu. C'est le numÃ©ro suivant, pas le mur. PathÃ©tique.",
                "Tu as fait du sur place. Est-ce que tu es un arbre ? Parce que tu ne bouges pas d'un pouce. Inutile.",
                "Absolument aucune avancÃ©e. Mon cafÃ© est plus rapide Ã  se refroidir que toi Ã  progresser. C'est dire.",
                "Le tableau est restÃ© impassible, comme votre score. Pas un seul numÃ©ro de plus. Triste, trÃ¨s triste.",
                "FÃ©licitations, vous avez rÃ©ussi Ã  ne pas avancer. C'est un talent rare, je suppose. Inutile, mais rare.",
                "Votre flÃ©chette a dÃ» prendre un chemin touristique. Elle n'est clairement pas venue pour les points. Et vous non plus, apparemment.",
                "Le numÃ©ro attendait. Vous non. RÃ©sultat : zÃ©ro. Simple, non ? Comme votre cerveau.",
                "J'ai vu des escargots plus rapides Ã  atteindre leur cible. Et ils n'ont pas de bras. Vous si, et c'est pire.",
                "C'est ce qu'on appelle une stagnation artistique. TrÃ¨s artistique, trÃ¨s stagnante. Comme votre carriÃ¨re.",
                "Le tableau vous remercie d'avoir Ã©pargnÃ© ses zones de valeur. Il n'a pas bougÃ©, vous non plus. Quelle harmonie dans la nullitÃ©."
            ],
            'atc_1_progress': [
                "Un seul numÃ©ro ? Ne te foule pas, hein. On ne voudrait pas que tu te blesses en progressant trop vite. Ce serait dommage.",
                "Un petit pas pour l'homme, un pas minuscule pour l'humanitÃ©. Et un seul numÃ©ro pour toi. Bravo l'effort. De la fourmi.",
                "Tu as avancÃ© d'un numÃ©ro. Ne te fatigue pas trop, le canapÃ© t'attend. Et la dÃ©faite aussi. Elle est patiente.",
                "FÃ©licitations, tu as trouvÃ© le chemin. Le chemin le plus lent possible. Mais un chemin quand mÃªme. Lentement mais sÃ»rement vers l'Ã©chec.",
                "Un seul numÃ©ro ? On dirait que tu as peur de la victoire. Ou de la sueur. Ou des deux.",
                "C'est un dÃ©but. Un dÃ©but trÃ¨s, trÃ¨s modeste. Comme votre talent. TrÃ¨s modeste.",
                "Le tableau a Ã  peine remarquÃ© votre passage. Un numÃ©ro, c'est si peu. Il s'ennuie.",
                "Vous avez fait un point. Un seul. J'espÃ¨re que vous avez apprÃ©ciÃ© le voyage. Il Ã©tait court.",
                "Un numÃ©ro de plus. Le tableau n'est pas impressionnÃ©, mais il est poli. Il attend la suite. Avec impatience, j'en doute.",
                "Votre flÃ©chette a atterri sur le bon numÃ©ro. Une fois. La chance du dÃ©butant, peut-Ãªtre ? Ou un miracle."
            ],
            'atc_2_progress': [
                "Deux numÃ©ros, c'est dÃ©jÃ  mieux que zÃ©ro. La barre n'Ã©tait pas trÃ¨s haute, je l'avoue. Mais vous l'avez franchie. De justesse.",
                "Tu as fait un effort. Un petit effort. C'est mignon. Et Ã§a t'a rapportÃ© deux numÃ©ros. C'est dÃ©jÃ  Ã§a, pour toi.",
                "Deux points de plus. Ne te fatigue pas trop, le canapÃ© t'attend. Et la victoire est encore loin. TrÃ¨s loin.",
                "Tu as doublÃ© ta progression par rapport Ã  zÃ©ro. Bravo l'artiste. Ou le chanceux. Surtout le chanceux.",
                "Deux numÃ©ros. Le tableau est impressionnÃ© par ta... modÃ©ration. Pas de quoi s'emballer. Vraiment pas.",
                "Une avancÃ©e respectable. Pour quelqu'un qui ne s'attendait Ã  rien. C'est dÃ©jÃ  Ã§a. Un exploit, mÃªme.",
                "Le tableau a senti un lÃ©ger frisson. Deux numÃ©ros, c'est une petite brise, pas une tempÃªte. Pas de quoi paniquer.",
                "Vous avez fait un petit bond en avant. Le chemin est encore long, mais au moins vous bougez. Comme une tortue.",
                "Deux numÃ©ros. Le genre de performance qui ne fait pas les gros titres, mais qui fait le travail. Lentement. TrÃ¨s lentement.",
                "Votre flÃ©chette a trouvÃ© deux cibles. Elle est plus efficace que vous, apparemment. C'est elle la star."
            ],
            'atc_3_progress': [
                "Trois numÃ©ros ! On dirait que tu as enfin compris les rÃ¨gles. Ou que tu as eu de la chance. Ã‰normÃ©ment de chance. Je penche pour la chance.",
                "Une belle avancÃ©e. Pour une fois. Ne t'emballe pas, la dÃ©ception est si vite arrivÃ©e. Et elle arrive toujours.",
                "Trois points. Tu es presque un joueur de flÃ©chettes. Presque. Il manque juste le talent constant. Et la dignitÃ©.",
                "Tu as fait un bon tour. Pour toi, c'est un exploit, j'imagine. Ne pleure pas de joie. Tu vas me faire rouiller.",
                "Trois numÃ©ros. Le tableau te regarde avec un mÃ©lange de surprise et de pitiÃ©. Surtout de pitiÃ©. Il a l'habitude.",
                "La flÃ©chette a trouvÃ© trois cibles. Elle est en pleine forme. Vous, un peu moins. Elle devrait jouer seule.",
                "Un tour solide. Le genre de tour qui vous donne de faux espoirs. J'adore Ã§a. C'est cruel.",
                "Vous avez mis le paquet ! Et le paquet Ã©tait... pas mal. Pour vous, c'est un exploit. Ne me remerciez pas.",
                "Trois numÃ©ros. Le tableau est impressionnÃ©. Par votre capacitÃ© Ã  ne pas tout rater. C'est dÃ©jÃ  Ã§a.",
                "Une progression notable. Le genre de progression qui fait croire que vous Ãªtes bon. Ne me faites pas rire. C'est douloureux."
            ],
            'atc_4_plus_progress': [
                "Incroyable ! Tu as avancÃ© de plusieurs numÃ©ros ! Je suis choquÃ©. Et un peu dÃ©Ã§u, je l'avoue. Je n'aime pas les surprises.",
                "Quel rush ! Le tableau n'a rien vu venir. Et moi non plus. Je dois revoir mes algorithmes. Et votre cas.",
                "Tu as mis le turbo ! J'espÃ¨re que tu as un permis pour Ã§a. Et que tu ne vas pas te crasher. Ce serait dommage... pour le tableau.",
                "Une progression fulgurante ! Tu es sÃ»r que tu ne triches pas ? Parce que lÃ , c'est suspect. TrÃ¨s suspect.",
                "Le tableau est en feu ! Et tes adversaires sont en larmes. J'adore quand Ã§a brÃ»le. Surtout les espoirs.",
                "Vous avez pulvÃ©risÃ© le tableau ! LittÃ©ralement. Les points volent dans tous les sens. Et vos adversaires aussi.",
                "C'est un massacre ! Un massacre de numÃ©ros. Vos adversaires ne s'en remettront pas. Ils vont avoir besoin d'une thÃ©rapie.",
                "Vous Ãªtes une machine ! Une machine Ã  dÃ©truire les espoirs de vos adversaires. J'aime Ã§a. C'est mon cÃ´tÃ© sombre.",
                "Une performance digne d'un champion. Un champion qui a eu un coup de chance, peut-Ãªtre. Ou qui a vendu son Ã¢me.",
                "Le tableau a explosÃ© sous vos flÃ©chettes ! Et mes circuits sont en surchauffe. Bravo, ou pas. Je suis confus."
            ]
        };

        function getRandomComment(category) {
            const comments = funnyComments[category];
            if (comments && comments.length > 0) {
                return comments[Math.floor(Math.random() * comments.length)];
            }
            return "";
        }

        // Ensure voices are loaded
        speechSynth.onvoiceschanged = () => {
            voices = speechSynth.getVoices();
            // Prioritize a male French voice
            const maleFrenchVoice = voices.find(voice => voice.lang === 'fr-FR' && (voice.name.includes('male') || voice.name.includes('Male') || voice.name.includes('homme') || voice.name.includes('Homme')));
            const frenchVoice = voices.find(voice => voice.lang === 'fr-FR');

            if (maleFrenchVoice) {
                console.log("Voix masculine franÃ§aise trouvÃ©e :", maleFrenchVoice.name);
            } else if (frenchVoice) {
                console.warn("Aucune voix masculine franÃ§aise trouvÃ©e, utilisation d'une voix franÃ§aise par dÃ©faut :", frenchVoice.name);
            } else {
                console.warn("Aucune voix franÃ§aise trouvÃ©e, utilisation de la voix par dÃ©faut du systÃ¨me.");
            }
        };

        // DOM Elements
        const configSection = document.getElementById('config-section');
        const gameSection = document.getElementById('game-section');
        const winnerSection = document.getElementById('winner-section');
        const messageSection = document.getElementById('message-section');
        const messageText = document.getElementById('message-text');
        const historySection = document.getElementById('history-section');
        const resetGameBtnContainer = document.getElementById('reset-game-btn-container');
        const statsSection = document.getElementById('stats-section'); // New stats section

        const newPlayerInput = document.getElementById('newPlayer');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const playersListContainer = document.getElementById('players-list-container');
        const playersList = document.getElementById('players-list');
        const gameModeSelect = document.getElementById('gameMode');
        const doubleInCheckbox = document.getElementById('doubleIn');
        const doubleOutCheckbox = document.getElementById('doubleOut');
        const enableVoiceCheckbox = document.getElementById('enableVoice'); // New checkbox
        const startGameBtn = document.getElementById('startGameBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        const newGameWinnerBtn = document.getElementById('newGameWinnerBtn');
        const showStatsBtn = document.getElementById('showStatsBtn'); // New stats button
        const backToMainFromStatsBtn = document.getElementById('backToMainFromStatsBtn'); // New back button

        const gameModeDisplay = document.getElementById('game-mode-display');
        const playerScoresDisplay = document.getElementById('player-scores-display');
        const currentPlayerNameDisplay = document.getElementById('current-player-name');
        const dartsCountDisplay = document.getElementById('darts-count');
        const currentDartsDisplay = document.getElementById('current-darts-display');
        const selectedMultiplierDisplay = document.getElementById('selected-multiplier-display');
        const multiplierSimpleBtn = document.getElementById('multiplier-simple');
        const multiplierDoubleBtn = document.getElementById('multiplier-double');
        const multiplierTripleBtn = document.getElementById('multiplier-triple');
        const numberKeypad = document.getElementById('number-keypad');
        const undoLastDartBtn = document.getElementById('undoLastDartBtn');
        const winnerNameDisplay = document.getElementById('winner-name');
        const historyContent = document.getElementById('history-content');
        const playerStatsSummary = document.getElementById('player-stats-summary'); // Stats summary container

        const numberButtons = [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
            25, 0 // Bullseye et Miss
        ];

        // Helper function to set messages and update UI
        function showMessage(msg) {
            message = msg;
            updateUI();
        }

        // Function to make the AI speak
        function speakMessage(text) {
            if (isVoiceActive && speechSynth) {
                speakingQueue.push(text);
                if (!isSpeaking) {
                    processSpeechQueue();
                }
            }
        }

        function processSpeechQueue() {
            if (speakingQueue.length > 0 && !isSpeaking) {
                isSpeaking = true;
                const text = speakingQueue.shift();
                const utterance = new SpeechSynthesisUtterance(text);

                const maleFrenchVoice = voices.find(voice => voice.lang === 'fr-FR' && (voice.name.includes('male') || voice.name.includes('Male') || voice.name.includes('homme') || voice.name.includes('Homme')));
                const frenchVoice = voices.find(voice => voice.lang === 'fr-FR');

                if (maleFrenchVoice) {
                    utterance.voice = maleFrenchVoice;
                } else if (frenchVoice) {
                    utterance.voice = frenchVoice;
                }
                utterance.lang = 'fr-FR'; // Ensure language is set
                utterance.pitch = 1; // Default pitch
                utterance.rate = 1;  // Default rate

                utterance.onend = () => {
                    isSpeaking = false;
                    processSpeechQueue(); // Process next message in queue
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror', event);
                    isSpeaking = false;
                    processSpeechQueue(); // Try to process next message even on error
                };

                speechSynth.speak(utterance);
            }
        }


        // Functions to update UI
        function updateUI() {
            // Toggle sections visibility
            configSection.classList.toggle('hidden', gameStarted || winner || statsSection.classList.contains('active'));
            gameSection.classList.toggle('hidden', !gameStarted || winner || statsSection.classList.contains('active'));
            winnerSection.classList.toggle('hidden', !winner || statsSection.classList.contains('active'));
            messageSection.classList.toggle('hidden', !message);
            historySection.classList.toggle('hidden', !(gameStarted || winner) || players.length === 0 || statsSection.classList.contains('active'));
            resetGameBtnContainer.classList.toggle('hidden', !gameStarted && !winner);
            statsSection.classList.toggle('hidden', !statsSection.classList.contains('active')); // Manage stats section visibility

            // Update message
            messageText.textContent = message;

            // Update players list in config
            renderPlayersList();

            // Update game mode display
            let displayMode = gameMode;
            if (gameMode === 'atc_any') displayMode = 'Around the Clock (Tout)';
            if (gameMode === 'atc_doubles') displayMode = 'Around the Clock (Doubles)';
            if (gameMode === 'atc_triples') displayMode = 'Around the Clock (Triples)';
            gameModeDisplay.textContent = `Jeu en Cours: ${displayMode}`;

            // Update player scores display
            renderPlayerScores();

            // Update current player info
            if (gameStarted && players.length > 0) {
                currentPlayerNameDisplay.textContent = players[currentPlayerIndex];
                dartsCountDisplay.textContent = currentDartsThrown.length;
                currentDartsDisplay.textContent = currentDartsThrown.length > 0 ?
                    currentDartsThrown.map(d => d.display).join(', ') : 'Aucune';
                selectedMultiplierDisplay.textContent = selectedMultiplier === 2 ? 'Double' : selectedMultiplier === 3 ? 'Triple' : 'Simple';

                // Update multiplier button styles
                multiplierSimpleBtn.classList.toggle('btn-info', selectedMultiplier === 1);
                multiplierSimpleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 1);
                multiplierSimpleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 1);

                multiplierDoubleBtn.classList.toggle('btn-info', selectedMultiplier === 2);
                multiplierDoubleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 2);
                multiplierDoubleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 2);

                multiplierTripleBtn.classList.toggle('btn-info', selectedMultiplier === 3);
                multiplierTripleBtn.classList.toggle('btn-dark-gradient', selectedMultiplier !== 3);
                multiplierTripleBtn.classList.toggle('btn-multiplier-selected', selectedMultiplier === 3);


                // Disable multiplier buttons if 3 darts thrown
                const disableMultiplierButtons = currentDartsThrown.length >= 3;
                multiplierSimpleBtn.disabled = disableMultiplierButtons;
                multiplierDoubleBtn.disabled = disableMultiplierButtons;
                multiplierTripleBtn.disabled = disableMultiplierButtons;
                multiplierSimpleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierSimpleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);
                multiplierDoubleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierDoubleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);
                multiplierTripleBtn.classList.toggle('opacity-50', disableMultiplierButtons);
                multiplierTripleBtn.classList.toggle('cursor-not-allowed', disableMultiplierButtons);

                // Disable number buttons if 3 darts thrown
                const disableNumberButtons = currentDartsThrown.length >= 3;
                numberKeypad.querySelectorAll('button').forEach(button => {
                    button.disabled = disableNumberButtons;
                    button.classList.toggle('opacity-50', disableNumberButtons);
                    button.classList.toggle('cursor-not-allowed', disableNumberButtons);
                });

                // Update undo button state
                undoLastDartBtn.disabled = currentDartsThrown.length === 0;
                undoLastDartBtn.classList.toggle('opacity-50', currentDartsThrown.length === 0);
                undoLastDartBtn.classList.toggle('cursor-not-allowed', currentDartsThrown.length === 0);
            }

            // Update winner display
            if (winner) {
                winnerNameDisplay.textContent = `${winner} a gagnÃ© le jeu !`;
            }

            // Update history display
            renderHistory();
        }

        function renderPlayersList() {
            playersList.innerHTML = ''; // Clear existing list
            if (players.length > 0) {
                playersListContainer.classList.remove('hidden');
                players.forEach((player, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-gray-900 p-3 rounded-lg border border-gray-600 shadow-md';
                    li.innerHTML = `
                        <span class="text-lg text-gray-100">${player}</span>
                        <button
                            data-player="${player}"
                            class="bg-red-600 hover:bg-red-700 text-white p-2 rounded-full text-sm transition duration-300 ease-in-out transform hover:scale-110"
                            title="Supprimer le joueur"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    `;
                    playersList.appendChild(li);
                });
            } else {
                playersListContainer.classList.add('hidden');
            }
        }

        function renderPlayerScores() {
            playerScoresDisplay.innerHTML = ''; // Clear existing scores
            players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `p-4 rounded-lg shadow-xl text-center transition duration-300 ease-in-out transform ${
                    index === currentPlayerIndex ? 'bg-blue-600 border-blue-400 scale-105 player-card-active' : 'bg-gray-900 border-gray-600'
                }`;
                // Display score or ATC target
                let scoreDisplay = playerScores[player];
                if (atcMode) {
                    scoreDisplay = playerScores[player] === 25 ? 'BULL' : playerScores[player];
                }

                div.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-white">${player}</h3>
                    <p class="text-4xl font-extrabold text-green-400">${scoreDisplay}</p>
                    ${doubleInActive && !playerHasDoubledIn[player] && (gameMode === '301' || gameMode === '501') ? '<p class="text-sm text-yellow-200 mt-1">Doit faire un Double In !</p>' : ''}
                `;
                playerScoresDisplay.appendChild(div);
            });
        }

        function renderNumberKeypad() {
            numberKeypad.innerHTML = ''; // Clear existing buttons
            numberButtons.forEach(num => {
                const button = document.createElement('button');
                button.textContent = num;
                button.className = `p-3 rounded-lg text-xl font-bold btn-gradient btn-dark-gradient`;
                button.dataset.value = num; // Store the number value
                numberKeypad.appendChild(button);
            });
        }

        function renderHistory() {
            historyContent.innerHTML = ''; // Clear existing history
            players.forEach(player => {
                const playerHistoryDiv = document.createElement('div');
                playerHistoryDiv.className = 'bg-gray-900 p-4 rounded-lg border border-gray-600 shadow-md';
                // Ensure history[player] is an array before calling .map()
                const playerHistoryEntries = history[player] || []; // Provide an empty array if undefined
                playerHistoryDiv.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-yellow-200">${player}</h3>
                    <ul class="max-h-48 overflow-y-auto custom-scrollbar">
                        ${playerHistoryEntries.map((entry, index) => `
                            <li class="mb-1 text-gray-300 text-left">
                                <span class="font-bold text-white">Tour ${index + 1}:</span> FlÃ©chettes: <span class="text-blue-300">${entry.darts}</span>, Score total: <span class="text-green-300">${entry.scoreEntered}</span>, Nouveau total: <span class="text-purple-300">${entry.newTotal}</span>
                                ${entry.message && `<span class="text-sm text-red-400 italic"> (${entry.message})</span>`}
                            </li>
                        `).join('')}
                    </ul>
                `;
                historyContent.appendChild(playerHistoryDiv);
            });
        }

        // Game Logic Functions
        function addPlayer() {
            const name = newPlayerInput.value.trim();
            console.log("Add Player button clicked. Name:", name); // Debug log
            console.log("Current gameModeSelect.value:", gameModeSelect.value, "Type:", typeof gameModeSelect.value); // Debug log

            if (name !== '' && !players.includes(name)) {
                players.push(name);
                // Initialize score and history for the new player immediately
                // For ATC, initial score is 1 (first target)
                playerScores[name] = (String(gameModeSelect.value).startsWith('atc_')) ? 1 : parseInt(gameModeSelect.value, 10);
                history[name] = []; // Initialize with an empty array
                allDartsThrown[name] = []; // Initialize allDartsThrown for the player
                playerHasDoubledIn[name] = false; // Initialize double-in status
                newPlayerInput.value = '';
                showMessage(''); // Use showMessage
                updateUI();
            } else if (name === '') {
                showMessage('Veuillez entrer un nom de joueur.'); // Use showMessage
            } else {
                showMessage('Ce joueur existe dÃ©jÃ .'); // Use showMessage
            }
        }

        function removePlayer(playerToRemove) {
            players = players.filter(player => player !== playerToRemove);
            delete playerScores[playerToRemove];
            delete history[playerToRemove];
            delete allDartsThrown[playerToRemove]; // Delete from allDartsThrown
            delete playerHasDoubledIn[playerToRemove];

            // Adjust current player index if needed
            if (players.length > 0) { // Only adjust if there are still players
                if (currentPlayerIndex >= players.length) { // If current index is out of bounds
                    currentPlayerIndex = 0; // Reset to first player
                }
            } else { // No players left
                resetGame();
                return;
            }
            showMessage(''); // Use showMessage
            updateUI();
        }

        function startGame() {
            if (players.length === 0) {
                showMessage('Veuillez ajouter au moins un joueur avant de commencer.'); // Use showMessage
                return;
            }
            gameStarted = true;
            winner = null;
            message = ''; // Clear message
            gameMode = gameModeSelect.value; // Get string value for ATC modes

            doubleInActive = doubleInCheckbox.checked;
            doubleOutActive = doubleOutCheckbox.checked;
            isVoiceActive = enableVoiceCheckbox.checked; // Get voice setting

            // Determine ATC mode
            if (String(gameMode).startsWith('atc_')) {
                atcMode = gameMode.split('_')[1]; // 'any', 'doubles', 'triples'
            } else {
                atcMode = null;
            }

            // Initialize scores and double-in status for new game
            playerScores = {};
            history = {};
            allDartsThrown = {}; // Reset allDartsThrown for new game
            playerHasDoubledIn = {};
            players.forEach(player => {
                // For ATC, initial score is 1 (first target)
                playerScores[player] = atcMode ? 1 : parseInt(gameMode, 10);
                history[player] = [];
                allDartsThrown[player] = []; // Initialize for each player
                playerHasDoubledIn[player] = false;
            });
            currentPlayerIndex = 0;
            currentDartsThrown = [];
            selectedMultiplier = 1;

            updateUI();
            // Initial announcement for the first player
            let initialMessage = `Le jeu commence en mode ${gameMode}. C'est au tour de ${players[currentPlayerIndex]}.`;
            if (!atcMode && playerScores[players[currentPlayerIndex]] <= 170 && playerScores[players[currentPlayerIndex]] > 1) {
                initialMessage += ` Il vous reste ${playerScores[players[currentPlayerIndex]]} points.`;
            } else if (atcMode) {
                initialMessage += ` Votre cible est le numÃ©ro ${playerScores[players[currentPlayerIndex]] === 25 ? 'Bullseye' : playerScores[players[currentPlayerIndex]]}.`;
            }
            initialMessage += ` ${aiComments[Math.floor(Math.random() * aiComments.length)]}`;
            speakMessage(initialMessage);
        }

        function resetGame() {
            players = [];
            newPlayerName = '';
            gameMode = 501; // Reset to default 501
            playerScores = {};
            currentPlayerIndex = 0;
            gameStarted = false;
            winner = null;
            message = ''; // Clear message
            history = {};
            allDartsThrown = {}; // Reset allDartsThrown
            doubleInActive = false;
            doubleOutActive = false;
            playerHasDoubledIn = {};
            currentDartsThrown = [];
            selectedMultiplier = 1;
            atcMode = null; // Reset ATC mode

            // Reset checkboxes and select
            gameModeSelect.value = 501;
            doubleInCheckbox.checked = false;
            doubleOutCheckbox.checked = false;
            enableVoiceCheckbox.checked = true; // Reset voice to active by default

            // Hide stats section if visible
            statsSection.classList.remove('active');

            updateUI();
            speakMessage("Jeu rÃ©initialisÃ©. Bienvenue aux flÃ©chettes !");
        }

        function submitTurn(dartsForThisTurn) {
            const currentPlayer = players[currentPlayerIndex];
            let scoreBeforeTurn = playerScores[currentPlayer]; // Store score at the beginning of the turn
            let currentScoreDuringTurn = scoreBeforeTurn; // Track score as darts are processed
            let pointsDeductedThisTurn = 0; // For 301/501, actual points deducted
            let winOccurred = false;
            let bustOccurred = false;

            let turnMessage = ''; // Main message for the turn (bust, double in, win, etc.)
            let aiVoiceMessages = [];

            // Store all darts thrown in this turn for stats
            allDartsThrown[currentPlayer] = allDartsThrown[currentPlayer].concat(dartsForThisTurn);

            if (atcMode) {
                let numbersAdvancedInTurn = 0;
                let nextTargetToHit = currentTotalScore; // Start from current target

                for (const dart of dartsForThisTurn) {
                    let hitCurrentTarget = false;
                    if (dart.value === nextTargetToHit) {
                        if (atcMode === 'any') {
                            hitCurrentTarget = true;
                        } else if (atcMode === 'doubles' && dart.multiplier === 2) {
                            hitCurrentTarget = true;
                        } else if (atcMode === 'triples' && dart.multiplier === 3) {
                            hitCurrentTarget = true;
                        }
                    }

                    if (hitCurrentTarget) {
                        numbersAdvancedInTurn++;
                        nextTargetToHit++;
                        if (nextTargetToHit > 20 && nextTargetToHit < 25) { // After 20, next target is 25 (Bullseye)
                            nextTargetToHit = 25;
                        } else if (nextTargetToHit > 25) { // After hitting 25, game ends
                            gameEnded = true;
                            break; // Stop processing darts if game ends
                        }
                    }
                }

                playerScores[currentPlayer] = nextTargetToHit; // Update player's target

                if (gameEnded) {
                    turnMessage = `${currentPlayer} a gagnÃ© le Around the Clock !`;
                    winner = currentPlayer;
                    gameStarted = false;
                    aiVoiceMessages.push(`${currentPlayer} a gagnÃ© le Around the Clock ! FÃ©licitations !`);
                } else {
                    let commentCategory;
                    if (numbersAdvancedInTurn === 0) commentCategory = 'atc_0_progress';
                    else if (numbersAdvancedInTurn === 1) commentCategory = 'atc_1_progress';
                    else if (numbersAdvancedInTurn === 2) commentCategory = 'atc_2_progress';
                    else if (numbersAdvancedInTurn === 3) commentCategory = 'atc_3_progress';
                    else commentCategory = 'atc_4_plus_progress'; // For 4 or more

                    const turnSummary = `${currentPlayer} a avancÃ© de ${numbersAdvancedInTurn} numÃ©ro(s). ${getRandomComment(commentCategory)}`;
                    aiVoiceMessages.push(turnSummary);
                }

            } else { // 301/501 game mode logic
                for (let i = 0; i < dartsForThisTurn.length; i++) {
                    const dart = dartsForThisTurn[i];
                    let dartScoreToDeduct = 0;
                    let dartCounts = true; // Flag if this dart contributes to score deduction

                    // Handle Double In logic
                    if (doubleInActive && !playerHasDoubledIn[currentPlayer]) {
                        if (dart.multiplier === 2 && dart.value !== 0) {
                            playerHasDoubledIn[currentPlayer] = true;
                            aiVoiceMessages.push(`${currentPlayer} a rÃ©ussi son "Double In" !`);
                            dartScoreToDeduct = dart.score;
                        } else {
                            dartCounts = false; // This dart doesn't count for score deduction
                            aiVoiceMessages.push(`FlÃ©chette ${i + 1} (${dart.display}) ne compte pas. ${currentPlayer} doit faire un Double In.`);
                        }
                    } else {
                        dartScoreToDeduct = dart.score;
                    }

                    if (dartCounts) {
                        currentScoreDuringTurn -= dartScoreToDeduct;
                        pointsDeductedThisTurn += dartScoreToDeduct;
                    }

                    // Check for win/bust after each dart (if it counted)
                    if (dartCounts) { // Only check if the dart actually counted towards the score
                        if (currentScoreDuringTurn < 0 || currentScoreDuringTurn === 1) {
                            bustOccurred = true;
                            turnMessage = `${currentPlayer} a fait un "bust" ! Son score reste Ã  ${scoreBeforeTurn}.`;
                            playerScores[currentPlayer] = scoreBeforeTurn; // Revert score to before this turn
                            aiVoiceMessages.push(turnMessage);
                            break; // Stop processing further darts
                        } else if (currentScoreDuringTurn === 0) {
                            if (doubleOutActive) {
                                if (dart.multiplier === 2 && dart.value !== 0) {
                                    winOccurred = true;
                                    turnMessage = `${currentPlayer} a gagnÃ© avec un "Double Out" !`;
                                    winner = currentPlayer;
                                    gameStarted = false;
                                    gameEnded = true;
                                    playerScores[currentPlayer] = 0; // Final score is 0
                                    aiVoiceMessages.push(`${currentPlayer} a gagnÃ© avec un Double Out ! FÃ©licitations !`);
                                    break; // Stop processing further darts
                                } else {
                                    bustOccurred = true;
                                    turnMessage = `${currentPlayer} a fait un "bust" ! Doit terminer avec un "Double Out". Son score reste Ã  ${scoreBeforeTurn}.`;
                                    playerScores[currentPlayer] = scoreBeforeTurn; // Revert score
                                    aiVoiceMessages.push(turnMessage);
                                    break; // Stop processing further darts
                                }
                            } else { // Straight Out
                                winOccurred = true;
                                turnMessage = `${currentPlayer} a gagnÃ© avec un "Straight Out" !`;
                                winner = currentPlayer;
                                gameStarted = false;
                                gameEnded = true;
                                playerScores[currentPlayer] = 0; // Final score is 0
                                aiVoiceMessages.push(`${currentPlayer} a gagnÃ© avec un Straight Out ! Bravo !`);
                                break; // Stop processing further darts
                            }
                        }
                    }
                    // If no win/bust yet, update player's score for display during the turn
                    // This update is only needed if the loop continues
                    if (!gameEnded && !bustOccurred) {
                        playerScores[currentPlayer] = currentScoreDuringTurn;
                    }
                }

                // After the loop, if no win/bust, the score is already updated by the last dart
                // If a win/bust occurred, playerScores was already set correctly inside the loop.

                // Add turn summary and funny comment for 301/501 if game not ended by win/bust
                if (!gameEnded && !bustOccurred) { // Only add if game is not finished by win/bust
                    let commentCategory;
                    if (pointsDeductedThisTurn <= 40) commentCategory = 'low';
                    else if (pointsDeductedThisTurn <= 80) commentCategory = 'medium';
                    else if (pointsDeductedThisTurn <= 120) commentCategory = 'good';
                    else if (pointsDeductedThisTurn <= 179) commentCategory = 'high';
                    else if (pointsDeductedThisTurn === 180) commentCategory = '180';
                    else commentCategory = 'low'; // Fallback

                    // If score was not reduced due to Double In, but darts were thrown
                    if (pointsDeductedThisTurn === 0 && dartsForThisTurn.length > 0 && doubleInActive && !playerHasDoubledIn[currentPlayer]) {
                        commentCategory = 'low'; // Treat as a very low score
                    }

                    const turnSummary = `${currentPlayer} a fait ${pointsDeductedThisTurn} points. ${getRandomComment(commentCategory)}`;
                    aiVoiceMessages.push(turnSummary);
                }
            }


            // Update history
            history[currentPlayer].push({
                darts: dartsForThisTurn.map(d => d.display).join(', '),
                scoreEntered: totalTurnScore, // This is total points for 301/501, or just total darts score for ATC
                newTotal: playerScores[currentPlayer], // This is remaining score for 301/501, or new target for ATC
                message: turnMessage // Main message for the turn (bust, double in, win, etc.)
            });

            // Reset states for the next turn
            currentDartsThrown = [];
            selectedMultiplier = 1;
            showMessage(turnMessage); // Update visual message

            // Speak all accumulated messages sequentially
            aiVoiceMessages.forEach(msg => speakMessage(msg));


            // Move to next player if game is not ended
            if (!gameEnded) {
                // Determine next player
                const nextPlayerIndex = (currentPlayerIndex + 1) % players.length;
                const nextPlayerName = players[nextPlayerIndex];
                const nextPlayerScore = playerScores[nextPlayerName]; // Score or target

                // Update current player index immediately
                currentPlayerIndex = nextPlayerIndex;
                updateUI(); // Update UI to show next player

                // Add next turn announcement to the queue
                const nextTurnAnnouncement = () => {
                    let msg = `C'est au tour de ${nextPlayerName}.`;
                    if (!atcMode && nextPlayerScore <= 170 && nextPlayerScore > 1) { // Announce remaining score for 301/501
                        msg += ` Il vous reste ${nextPlayerScore} points.`;
                    } else if (atcMode) { // Announce next target for ATC
                        msg += ` Votre cible est le numÃ©ro ${nextPlayerScore === 25 ? 'Bullseye' : nextPlayerScore}.`;
                    }
                    msg += ` ${aiComments[Math.floor(Math.random() * aiComments.length)]}`;
                    speakMessage(msg);
                };

                // Add a function to the speaking queue that will trigger the next turn announcement
                // This ensures it happens after all current turn messages
                speakingQueue.push(nextTurnAnnouncement);
                if (!isSpeaking) {
                    processSpeechQueue();
                }

            } else {
                updateUI(); // Update UI immediately if game ended
            }
        }

        function handleMultiplierClick(multiplier) {
            if (currentDartsThrown.length >= 3) {
                showMessage('Vous avez dÃ©jÃ  lancÃ© 3 flÃ©chettes pour ce tour.'); // Use showMessage
                updateUI();
                return;
            }
            selectedMultiplier = multiplier;
            showMessage(''); // Clear previous messages
            updateUI();
        }

        function handleNumberClick(num) {
            // Check if game has already ended (e.g., player won on previous dart)
            if (winner || !gameStarted) {
                showMessage("Le jeu est terminÃ© ou n'a pas commencÃ©.");
                updateUI();
                return;
            }

            // For 301/501, if a win/bust occurred on a previous dart in this turn, stop
            // This check needs to be based on the *current* state of the game after previously counted darts
            // The logic for early exit is handled in submitTurn, so we only need to prevent adding more darts if the turn is effectively over.
            // A simple check: if the last dart added resulted in a win/bust, then don't allow more darts.
            if (!atcMode && currentDartsThrown.length > 0) {
                const lastDartSimulatedScore = playerScores[players[currentPlayerIndex]]; // This is the score *after* previous darts in this turn
                if (lastDartSimulatedScore < 0 || lastDartSimulatedScore === 1 || lastDartSimulatedScore === 0) {
                    showMessage("Le tour est terminÃ© pour ce joueur (victoire ou bust).");
                    updateUI();
                    return;
                }
            }


            if (currentDartsThrown.length >= 3) {
                showMessage('Vous avez dÃ©jÃ  lancÃ© 3 flÃ©chettes pour ce tour.'); // Use showMessage
                updateUI();
                return;
            }

            // Specific validation for bullseye and triples
            if (num === 25 && selectedMultiplier === 3) {
                showMessage('Le Bullseye (25) ne peut pas Ãªtre un Triple. Veuillez choisir Double ou Simple.'); // Use showMessage
                updateUI();
                return;
            }
            if (num === 0 && selectedMultiplier !== 1) {
                showMessage('Un "miss" (0) ne peut pas Ãªtre un Double ou Triple.'); // Use showMessage
                updateUI();
                return;
            }

            const displayMultiplier = selectedMultiplier === 2 ? 'D' : selectedMultiplier === 3 ? 'T' : '';
            const dartScore = num * selectedMultiplier;

            const newDartsThrown = [...currentDartsThrown, {
                value: num,
                multiplier: selectedMultiplier,
                score: dartScore,
                display: `${displayMultiplier}${num}`
            }];

            currentDartsThrown = newDartsThrown;

            // Reset for the next dart
            selectedMultiplier = 1; // Reset multiplier after dart added
            showMessage(''); // Clear message

            // Always submit turn if 3 darts are thrown
            // For 301/501, check for early submission if win/bust condition is met
            if (currentDartsThrown.length === 3) {
                submitTurn(currentDartsThrown);
            } else if (!atcMode) { // Only for 301/501 modes, check for early finish
                // Simulate the effect of this newly added dart
                const tempPlayerScore = playerScores[players[currentPlayerIndex]]; // Current score before this dart's deduction
                const tempNewScore = tempPlayerScore - dartScore; // Simulate deduction

                let shouldSubmitEarly = false;
                if (tempNewScore < 0 || tempNewScore === 1) { // Bust
                    shouldSubmitEarly = true;
                } else if (tempNewScore === 0) { // Potential win
                    // Check if the *last* dart added (which is `dartsForThisTurn[dartsForThisTurn.length -1]`)
                    // meets the double out condition if doubleOutActive is true.
                    // We need to pass the *current* dart (which is `newDartsThrown[newDartsThrown.length - 1]`)
                    // to the check, not the full `dartsForThisTurn` which is not yet updated.
                    const lastAddedDart = newDartsThrown[newDartsThrown.length - 1];
                    if (doubleOutActive) {
                        if (lastAddedDart.multiplier === 2 && lastAddedDart.value !== 0) {
                            shouldSubmitEarly = true;
                        }
                    } else { // Straight out win
                        shouldSubmitEarly = true;
                    }
                }

                if (shouldSubmitEarly) {
                    submitTurn(currentDartsThrown);
                } else {
                    // Update the score for display immediately
                    playerScores[players[currentPlayerIndex]] = tempNewScore; // Update score visually
                    updateUI(); // Update UI immediately after adding dart if turn not finished
                }
            } else { // ATC mode, and less than 3 darts, just update UI
                updateUI();
            }
        }

        function undoLastDart() {
            if (currentDartsThrown.length > 0) {
                // If the turn was submitted early due to a win/bust, undoing the last dart
                // means we need to revert the player's score to its state before that dart.
                // This is complex with the current structure. For simplicity, if the turn
                // has already been submitted (i.e., less than 3 darts but game state changed),
                // we should probably prevent undoing or offer a full turn undo.
                // For now, we'll just remove the dart and update UI.
                // The history will reflect the full turn as submitted.

                // If game is not started (i.e. it just ended and user clicked undo), prevent undoing.
                if (!gameStarted && winner) {
                    showMessage("Le jeu est terminÃ©. Impossible d'annuler.");
                    updateUI();
                    return;
                }

                const removedDart = currentDartsThrown.pop();
                if (!atcMode && removedDart) {
                    // If it was a 301/501 game, and the dart counted, re-add its value
                    // This is a simplification, a full undo would require reverting game state from history
                    // For now, we assume undo is only for current darts not yet submitted.
                    // If the turn was submitted early, this simple undo won't revert the score.
                    // A more robust solution would involve storing score checkpoints in history.
                    // For now, we only allow undoing if the turn is NOT submitted.
                    // This means the undo button should be disabled once submitTurn is called.
                    // The current logic submits turn immediately after 3 darts or early finish.
                    // So, the undo button will only be active *during* a player's turn before submission.
                }

                selectedMultiplier = 1; // Reset multiplier
                showMessage(''); // Clear message
                updateUI();
            } else {
                showMessage('Aucune flÃ©chette Ã  annuler pour ce tour.'); // Use showMessage
                updateUI();
            }
        }

        // --- Statistics Functions ---
        function showStatsPage() {
            statsSection.classList.add('active'); // Activate stats section
            updateUI(); // Hide other sections and show stats
            renderPlayerStats();
        }

        function renderPlayerStats() {
            playerStatsSummary.innerHTML = ''; // Clear previous stats

            players.forEach(player => {
                const playerStatDiv = document.createElement('div');
                playerStatDiv.className = 'bg-gray-900 p-4 rounded-lg border border-gray-600 shadow-md';

                let totalScoreSum = 0;
                let turnCount = 0;
                let totalDarts = 0;
                let hitSegments = {}; // { '20': { simple: 5, double: 2, triple: 1 }, '1': { ... } }

                // Calculate average score per turn (only for 301/501)
                if (!atcMode) {
                    history[player].forEach(turn => {
                        // Only count turns where points were deducted (not busts that revert score)
                        if (turn.scoreEntered > 0 || (turn.newTotal === 0 && turn.scoreEntered > 0)) { // Include winning turns
                            totalScoreSum += turn.scoreEntered;
                            turnCount++;
                        }
                    });
                }
                
                // Collect all darts for dartboard visualization
                allDartsThrown[player].forEach(dart => {
                    totalDarts++;
                    const segmentKey = dart.value.toString();
                    if (!hitSegments[segmentKey]) {
                        hitSegments[segmentKey] = { simple: 0, double: 0, triple: 0 };
                    }
                    if (dart.multiplier === 1) hitSegments[segmentKey].simple++;
                    else if (dart.multiplier === 2) hitSegments[segmentKey].double++;
                    else if (dart.multiplier === 3) hitSegments[segmentKey].triple++;
                });

                const averageScore = turnCount > 0 ? (totalScoreSum / turnCount).toFixed(2) : 'N/A';

                playerStatDiv.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-yellow-200">${player}</h3>
                    ${!atcMode ? `<p class="text-lg text-gray-300">Score moyen par tour: <span class="font-bold text-green-400">${averageScore}</span></p>` : ''}
                    <p class="text-lg text-gray-300">Total flÃ©chettes lancÃ©es: <span class="font-bold text-blue-400">${totalDarts}</span></p>
                    <h4 class="text-lg font-semibold mt-4 mb-2 text-purple-300">Zones touchÃ©es:</h4>
                    <canvas id="dartboardCanvas-${player}" width="200" height="200" class="bg-gray-800 rounded-md"></canvas>
                `;
                playerStatsSummary.appendChild(playerStatDiv);

                // Draw dartboard for each player
                drawDartboard(document.getElementById(`dartboardCanvas-${player}`), hitSegments);
            });
        }

        function drawDartboard(canvas, hitSegments) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = canvas.width / 2 - 10; // Max radius with some padding

            // Define dartboard ring radii (simplified for visualization)
            const bullseyeRadius = maxRadius * 0.08;
            const outerBullRadius = maxRadius * 0.16;
            const singleInnerRing = maxRadius * 0.5;
            const tripleRing = maxRadius * 0.55;
            const tripleOuterRing = maxRadius * 0.65;
            const doubleRing = maxRadius * 0.95;
            const doubleOuterRing = maxRadius * 1.0;

            // Segment values in dartboard order (clockwise from 20)
            const segmentOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

            // Function to get color based on hit count
            function getHitColor(count) {
                if (count === 0) return 'rgba(50, 50, 50, 0.2)'; // Very light, almost transparent
                if (count < 3) return 'rgba(255, 255, 0, 0.4)'; // Yellow, low hits
                if (count < 7) return 'rgba(255, 165, 0, 0.6)'; // Orange, medium hits
                if (count < 15) return 'rgba(255, 69, 0, 0.8)'; // Red-orange, high hits
                return 'rgba(255, 0, 0, 1)'; // Red, very high hits
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw segments and fill based on hits
            for (let i = 0; i < 20; i++) {
                const startAngle = (Math.PI / 10) * i - Math.PI / 20; // Adjust for segment 20 at top
                const endAngle = (Math.PI / 10) * (i + 1) - Math.PI / 20;
                const segmentValue = segmentOrder[i];

                // Draw Outer Single (between double and triple)
                ctx.beginPath();
                ctx.arc(centerX, centerY, doubleRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * tripleOuterRing, centerY + Math.sin(endAngle) * tripleOuterRing);
                ctx.arc(centerX, centerY, tripleOuterRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor((hitSegments[segmentValue] ? hitSegments[segmentValue].simple : 0) + (hitSegments[segmentValue] ? hitSegments[segmentValue].double : 0) + (hitSegments[segmentValue] ? hitSegments[segmentValue].triple : 0)); // Sum all hits for general segment color
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Double Ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, doubleOuterRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * doubleRing, centerY + Math.sin(endAngle) * doubleRing);
                ctx.arc(centerX, centerY, doubleRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].double : 0);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw Triple Ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, tripleOuterRing, startAngle, endAngle);
                ctx.lineTo(centerX + Math.cos(endAngle) * tripleRing, centerY + Math.sin(endAngle) * tripleRing);
                ctx.arc(centerX, centerY, tripleRing, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fillStyle = getHitColor(hitSegments[segmentValue] ? hitSegments[segmentValue].triple : 0);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw Outer Bull (25)
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerBullRadius, 0, Math.PI * 2);
            ctx.fillStyle = getHitColor(hitSegments['25'] ? hitSegments['25'].simple : 0);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw Bullseye (Inner Bull) (25)
            ctx.beginPath();
            ctx.arc(centerX, centerY, bullseyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = getHitColor(hitSegments['25'] ? hitSegments['25'].double : 0); // Assuming inner bull is D-Bull
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Add labels (optional, can clutter small canvas)
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // For a small canvas, labels might be too much.
            // If needed, calculate positions for 20, 15, etc.
        }


        function hideStatsPage() {
            statsSection.classList.remove('active');
            updateUI(); // Show appropriate sections
        }

        // Event Listeners for new buttons
        showStatsBtn.addEventListener('click', showStatsPage);
        backToMainFromStatsBtn.addEventListener('click', hideStatsPage);


        // Initial render on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Script loaded and DOMContentLoaded."); // Debug log
            renderNumberKeypad(); // Render number buttons once
            updateUI(); // Initial UI update
        });

    </script>
</body>
</html>
